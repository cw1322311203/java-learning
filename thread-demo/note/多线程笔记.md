# 1.实现多线程

## 1.1简单了解多线程【理解】

是指从软件或者硬件上实现多个线程并发执行的技术。
具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。

![01_简单了解多线程](https://img-blog.csdnimg.cn/20210129151045316.png)

## 1.2并发和并行【理解】

+ 并行Parallel：在同一时刻，有多个指令在**多个**CPU上**同时**执行。

  多个CPU同时执行多个任务。在同一时刻，有多条指令在多个处理器上同时执行。

  ![02_并行](https://img-blog.csdnimg.cn/20210129151109614.png)

+ 并发Concurrent：在同一时刻，有多个指令在**单个**CPU上**交替**执行。

  一个CPU（采用时间片）同时执行多个任务。在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。
  
  ![03_并发](https://img-blog.csdnimg.cn/20210129151126163.png)
  
  ![并发与并行的概念图解](https://img-blog.csdnimg.cn/20210129151150732.png)

## 1.3 程序,进程和线程【理解】

### 1.3.1 程序

程序是一段静态的代码，它是应用程序执行的蓝本，是一个静态的概念

### 1.3.2 进程

是正在运行的程序

进程有自己的地址空间，当一个程序进入内存运行时，即变成了一个进程

进程是系统进行资源分配和调度的一个独立单位。进程是程序在处理机上的一次执行过程，它是一个动态的概念。

**进程的特点**

- 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位

  进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。

- 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的

  进程和程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，这些概念在程序中都是不具备的。

- 并发性：任何进程都可以同其他进程一起并发执行

  多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响。

### 1.3.3 线程

是进程中的单个顺序控制流，是一条执行路径

进程内部的一个执行单元，负责当前进程中程序的执行,它是程序中一个单一的顺序控制流程。

线程又被称为轻量级进程，如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为多线程 

单线程：一个进程如果只有一条执行路径，则称为单线程程序

多线程：一个进程如果有多条执行路径，则称为多线程程序

一个进程中至少有一个线程，一个进程中是可以有多个线程。

**线程特点**

- 轻量级进程
- 独立调度的基本单位
- 可并发执行
- 共享进程资源

 **注意**：线程优先级别越高，CPU分配给线程的机会越多	![04_多线程示例](https://img-blog.csdnimg.cn/20210129151226630.png)

### 1.3.4 线程与进程案例

1. 运行中迅雷可以称为一个进程，而迅雷中的各个下载任务可以成为一个线程，每个下载任务共享进程(迅雷)的资源。

2. 南北两车道每个车道可以称为一个进程，而每个车道中的左中右车道又可以称为一个线程

### 1.3.5 线程和进程的区别

| 区别     | 进程                                                         | 线程                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 根本区别 | 作为资源分配的单位                                           | 调度和执行的单位                                             |
| 开    销 | 每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。 | 线程可以看成时轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。 |
| 所处环境 | 在操作系统中能同时运行多个任务(程序)                         | 在同一应用程序中有多个顺序流同时执行                         |
| 分配内存 | 系统在运行的时候会为每个进程分配不同的内存区域               | 除了CPU之外，不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源 |
| 包含关系 | 没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。 | 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。 |

## 1.4 线程的创建和启动

Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流(一段顺序执行的代码)。Java使用线程执行体来代表这段程序流

**注意：**

1. 一运行main方法，就启动一个main线程。main方法可以开启其他多个线程start()

2. **主线程**:执行主(main)方法的线程   

   **单线程程序**:java程序中只有一个线程

   执行从main方法开始,从上到下依次执行。JVM执行main方法,main方法会进入到栈内存

   JVM会找操作系统开辟一条main方法通向cpu的执行路径,cpu就可以通过这个路径来执行main方法,而这个路径有一个名字,叫main(主)线程

3. 当Java程序开始运行后，程序至少会创建一个主线程，主线程的线程执行体不是由run()方法确定的，而是由main()方法确定的-main()方法的方法体代表主线程的线程执行体。

**线程的启动**

- 新建的线程不会自动开始运行，必须通过start( )方法启动

- **不能直接调用run()来启动线程，这样run()将作为一个普通方法立即执行，执行完毕前其他线程无法兵法执行**
- Java程序启动时，会立刻创建主线程，main就是在这个线程上运行。当不再产生新线程时，程序是单线程的

## 1.5 实现多线程方式一：继承Thread类【应用】

### 1.5.1 方法介绍

java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类

**Thread线程常用方法：**

- public void run()：线程执行体,在线程开启后，此方法将被调用执行  
- String getName() : 返回该线程的名称。
- Thread.currentThread() ：返回当前正在执行的线程对象,是Thread类的静态方法。
- void setName(String name) 改变线程名称，使之与参数 name 相同。
- Thread() :分配一个新的线程对象
- Thread(String name) 分配一个指定名字的新的 Thread 对象。
- Thread(Runnable target) 分配一个带有指定目标新的线程对象
- Thread(Runnable target,String name) 分配一个带有指定目标新的线程对象并指定名字
- int getPriority() 获得线程的优先级数值
- void setPriority() 设置线程的优先级数值
- void start( ) 调用run( )方法启动线程，开始线程的执行
- isAlive() 判断线程是否还“活”着，即线程是未终止
- public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。毫秒数结束之后,线程继续执行

### 1.4.2 实现步骤

1. 创建一个Thread类的子类

2. 在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)
   ~~~java
   public class TortoiseThread extends Thread{
      	public void run() {//线程体}
   }
   ~~~

   run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。

3. 创建Thread类的子类对象

   ~~~java
   TortoiseThread thread = new TortoiseThread();
   ~~~

4. 调用Thread类中的方法start方法,开启新的线程,执行run方法
   ~~~java
   //thread.run();//这不是在启动线程，是在调用方法run()
   thread.start();//启动线程，不见得立刻执行，而是进入就绪队列，等待获得CPU，也不会一直占用CPU,分时间片交替执行
   ~~~
   
   void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
   
   结果是两个线程**并发**地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。
   
   多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
   
   java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行



### 1.4.3 代码演示

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        for(int i=0; i<100; i++) {
            System.out.println(i);
        }
    }
}
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();

//        my1.run();
//        my2.run();

        //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法
        my1.start();
        my2.start();
    }
}
```

- 两个小问题

  - 为什么要重写run()方法？

    因为run()是用来封装被线程执行的代码

  - run()方法和start()方法的区别？

    run()：封装线程执行的代码，直接调用，相当于普通方法的调用

    start()：启动线程；然后由JVM调用此线程的run()方法

## 1.5 实现多线程方式二：实现Runnable接口【应用】

java.lang.Runnable: Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。

### 1.5.1 Thread构造方法

| 方法名                                  | 说明             |
| ------------------------------------ | -------------- |
| Thread(Runnable target)              | 分配一个新的Thread对象 |
| Thread(Runnable target, String name) | 分配一个新的Thread对象 |

Thread类实际上也是实现了Runnable接口的类。实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的。

**注意**：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法

### 1.5.2 实现步骤

- 定义一个类MyRunnable实现Runnable接口
- 在MyRunnable类中重写run()方法
- 创建MyRunnable类的对象
- 创建Thread类的对象，把MyRunnable对象作为构造方法的参数
- 启动线程

### 1.5.3 实现Runnable接口创建多线程程序的好处

1. 避免了单继承的局限性

   一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类

   实现了Runnable接口,还可以继承其他的类,实现其他的接口

2. 增强了程序的扩展性,降低了程序的耦合性(解耦)

   实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)

   实现类中,重写了run方法:用来设置线程任务

   创建Thread类对象,调用start方法:用来开启新线程

### 1.5.4 两种定义线程的方式优缺点分析

**方式1：继承Thread**

- 优点：代码简单些
- 缺点：继承了Thread类，不能再继承其他类

**方式2：实现Runnable接口**

- 优点：可以继承其他类，多线程可共享同一个Runnable对象
  如果多个线程之间共享数据，更建议通过该方式实现
- 缺点：编程方式稍微复杂，如果需要访问当前线程，需要调用Thread.currentThread()方法
  实现Runnable接口方式要通用一些。

### 1.5.5 代码演示

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int i=0; i<100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}
public class MyRunnableDemo {
    public static void main(String[] args) {
        //创建MyRunnable类的对象
        MyRunnable my = new MyRunnable();

        //创建Thread类的对象，把MyRunnable对象作为构造方法的参数
        //Thread(Runnable target)
//        Thread t1 = new Thread(my);
//        Thread t2 = new Thread(my);
        //Thread(Runnable target, String name)
        Thread t1 = new Thread(my,"坦克");
        Thread t2 = new Thread(my,"飞机");

        //启动线程
        t1.start();
        t2.start();
    }
}
```

### 1.5.6 匿名内部类方式实现线程的创建

匿名:没有名字

内部类:写在其他类内部的类

匿名内部类作用:简化代码

把子类继承父类,重写父类的方法,创建子类对象合一步完成

把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成

匿名内部类的最终产物:子类/实现类对象,而这个类没有名字

格式:

​    new 父类/接口(){

​        重复父类/接口中的方法

​    };

~~~java
// 第一种
new Thread(){
            //重写run方法,设置线程任务
            @Override
            public void run() {
                for (int i = 0; i <20 ; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"黑马");
                }
            }
        }.start();

// 第二种
 Runnable r = new Runnable(){
            //重写run方法,设置线程任务
            @Override
            public void run() {
                for (int i = 0; i <20 ; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"程序员");
                }
            }
        };
        new Thread(r).start();

// 第三种
new Thread(new Runnable(){
            //重写run方法,设置线程任务
            @Override
            public void run() {
                for (int i = 0; i <20 ; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+"传智播客");
                }
            }
        }).start();
~~~

## 1.6实现多线程方式三: 实现Callable接口【应用】

### 1.6.1 认识Callable

Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。

Callable接口提供了一个call()方法作为线程执行体,但call()方法比run()方法功能更强大。

Java 5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口-----可以作为Thread类的target。

**认识Callable**

1. 有返回值
2. 支持泛型
3. 支持异常抛出(runable只能抛出运行时异常，而Callable可以抛出所有的异常)
4. JDK1.5提供
5. 功能强大，如果需要返回值，必须使用该方式
6. java.util.concurrent.Callable是一个泛型接口，只有一个call()方法
7. call()方法抛出异常Exception异常，且返回一个指定的泛型类对象

**注意**:Callable接口有泛型限制，**Callable接口里的泛型形参类型与call()方法返回值类型相同**

### 1.6.2 实现步骤

1. 创建Callable接口的实现类,并实现call()方法,该call()方法将作为线程执行体，且该方法有返回值

   ~~~java
   public class RandomCallable implements Callable<Integer>{
   	public Integer call() throws Exception {}
   ｝
   ~~~

2. 创建Callable实现类的实例。

   ~~~java
   Callable callable =new RandomCallable();
   ~~~

3. 使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值

   ~~~java
   FutureTask<Integer> task = new FutureTask(callable);
   ~~~

4. 使用FutureTask对象作为Thread对象的target创建并启动新线程

   ~~~java
   Thread thread = new Thread(task);
   thread.start();
   ~~~

5. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

   ~~~java
   int result = task.get();//要等线程返回结果，程序再次阻塞
   System.out.println(result);
   ~~~

   **注意:get()方法会返回Callable任务里call()方法的返回值。调用该方法将会导致程序阻塞，必须等到子线程结束后才会得到返回值。**

### 1.6.3 认识FutureTask

~~~java
public class FutureTask<V> implements RunnableFuture<V>
public interface RunnableFuture<V> extends Runnable, Future<V>
public class FutureTask<V> implements  Runnable, Future<V>
- 作用1：Runnable：创建线程是作为参数传入
- 作用2：Future：启动线程后对线程进行处理：获取返回值get(),判断是否结束isDone()
~~~

**Future接口**

可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

FutrueTask是Futrue接口的唯一的实现类

FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值

**Future接口方法**

- **boolean cancel(boolean mayInterruptIfRunning)** : 试图取消该Future里关联的Callable任务
- **V get()** :返回Callable任务里call()方法的返回值。调用该方法将会导致程序阻塞，必须等到子线程(子线程Call()结束并返回值)结束后才会得到返回值。
- **V get(long timeout, TimeUnit unit)** :返回Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务仍然没有返回值，将会抛出TimeoutException异常。
- **boolean isCancelled()**:如果在Callable任务正常完成前被取消，则返回true。
- **boolean isDone()**:如果Callable任务已完成，则返回true。

**方法介绍**

| 方法名                            | 说明                                               |
| --------------------------------- | -------------------------------------------------- |
| V call()                          | 计算结果，如果无法计算结果，则抛出一个异常         |
| FutureTask(Callable\<V> callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable |
| V get()                           | 如有必要，等待计算完成，然后获取其结果             |

### 1.6.4 代码演示

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println("跟女孩表白" + i);
        }
        //返回值就表示线程运行完毕之后的结果
        return "答应";
    }
}
public class Demo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //线程开启之后需要执行里面的call方法
        MyCallable mc = new MyCallable();

        //Thread t1 = new Thread(mc);

        //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象
        FutureTask<String> ft = new FutureTask<>(mc);

        //创建线程对象
        Thread t1 = new Thread(ft);

        String s = ft.get();
        //开启线程
        t1.start();

        //String s = ft.get();
        System.out.println(s);
    }
}
```



## 1.7 三种实现方式的对比

|                            | 好处                                         | 缺点                                       |
| -------------------------- | -------------------------------------------- | ------------------------------------------ |
| 实现Runnable、Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类 | 编程相对复杂，不能直接使用Thread类中的方法 |
| 继承Thread类               | 编程比较简单，可以直接使用Thread类中的方法   | 可以扩展性较差，不能再继承其他的类         |

通过继承Thread类或实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法**有返回值**，可以**声明抛出异常**而已。因此可以将实现Runnable接口和实现Calable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。

采用实现Runnable、Callable接口的方式创建多线程的优缺点：

- 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。	
- 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
- 劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread)方法。

采用继承Thread类的方式创建多线程的优缺点：

- 劣势是，因为线程类已经继承了Thread类，所以不能再继承其他父类。
- 优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this可获得当前线程。

鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

## 1.8 设置和获取线程名称【应用】

方法介绍

| 方法名                        | 说明                 |
| -------------------------- | ------------------ |
| void  setName(String name) | 将此线程的名称更改为等于参数name |
| String  getName()          | 返回此线程的名称           |
| Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |

代码演示

```java
public class MyThread extends Thread {
    public MyThread() {}
    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName()+":"+i);
        }
    }
}
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();

        //void setName(String name)：将此线程的名称更改为等于参数 name
        my1.setName("高铁");
        my2.setName("飞机");

        //Thread(String name)
        MyThread my1 = new MyThread("高铁");
        MyThread my2 = new MyThread("飞机");

        my1.start();
        my2.start();

        //static Thread currentThread() 返回对当前正在执行的线程对象的引用
        System.out.println(Thread.currentThread().getName());
    }
}
```

## 1.9 线程休眠【应用】

+ 相关方法

  | 方法名                            | 说明                       |
  | ------------------------------ | ------------------------ |
  | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |

+ 代码演示

  ```java
  public class MyRunnable implements Runnable {
      @Override
      public void run() {
          for (int i = 0; i < 100; i++) {
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }

              System.out.println(Thread.currentThread().getName() + "---" + i);
          }
      }
  }
  public class Demo {
      public static void main(String[] args) throws InterruptedException {
          /*System.out.println("睡觉前");
          Thread.sleep(3000);
          System.out.println("睡醒了");*/

          MyRunnable mr = new MyRunnable();

          Thread t1 = new Thread(mr);
          Thread t2 = new Thread(mr);

          t1.start();
          t2.start();
      }
  }
  ```

## 1.10 线程优先级【应用】

线程调度

- 两种调度方式
  - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
  - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些

Java使用的是抢占式调度模型

- 随机性

  假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的

  ![05_多线程示例图](https://img-blog.csdnimg.cn/20210129151302676.png)

优先级相关方法

| 方法名                                     | 说明                                |
| --------------------------------------- | --------------------------------- |
| final int getPriority()                 | 返回此线程的优先级                         |
| final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |

代码演示

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "---" + i);
        }
        return "线程执行完毕了";
    }
}
public class Demo {
    public static void main(String[] args) {
        //优先级: 1 - 10 默认值:5
        MyCallable mc = new MyCallable();

        FutureTask<String> ft = new FutureTask<>(mc);

        Thread t1 = new Thread(ft);
        t1.setName("飞机");
        t1.setPriority(10);
        //System.out.println(t1.getPriority());//5
        t1.start();

        MyCallable mc2 = new MyCallable();

        FutureTask<String> ft2 = new FutureTask<>(mc2);

        Thread t2 = new Thread(ft2);
        t2.setName("坦克");
        t2.setPriority(1);
        //System.out.println(t2.getPriority());//5
        t2.start();
    }
}
```

## 1.11 守护线程【应用】

- 相关方法

  | 方法名                        | 说明                                   |
  | -------------------------- | ------------------------------------ |
  | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |

- 代码演示

  ```java
  public class MyThread1 extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 10; i++) {
              System.out.println(getName() + "---" + i);
          }
      }
  }
  public class MyThread2 extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 100; i++) {
              System.out.println(getName() + "---" + i);
          }
      }
  }
  public class Demo {
      public static void main(String[] args) {
          MyThread1 t1 = new MyThread1();
          MyThread2 t2 = new MyThread2();

          t1.setName("女神");
          t2.setName("备胎");

          //把第二个线程设置为守护线程
          //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.
          t2.setDaemon(true);

          t1.start();
          t2.start();
      }
  }
  ```



# 2.线程控制

## 2.1 join ()

阻塞指定线程等到另一个线程完成以后再继续执行

当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。

A正在执行  B join  B执行完  A再开始执行

join()方法有如下三种重载形式。

- join()  :等待被join的线程执行完成
- join(long millis): 等待被join的线程的时间最长为millis毫秒。如果在millis毫秒内被join的线程还没有执行结束，则不再等待。
- join(long millis,int nanos):等待被join的线程的时间最长为millis毫秒加nanos毫微秒。

代码演示

~~~java
public static void main(String[] args) {
        int i = 0;
        while(i<=10){
            if(i==5){
                Thread thread = new TortoiseThread();//创建线程对象  新生状态
                thread.start();//就绪状态
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("兔子领先了，加油......"+i);
            i++;
        }
    } 
public class TortoiseThread extends Thread{
    public void run() {
        int i= 0;
        while(i<=10){
            System.out.println("乌龟领先了，add oil...."+i);
            i++;
        }
    }
}
~~~

![运行截图](https://img-blog.csdnimg.cn/202101291513332.png)

## 2.2 sleep ()

**使线程停止运行一段时间，将处于阻塞状态,时间到后会进入就绪状态，而不是运行状态**

如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行！

当前线程调用sleep()方法进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行的机会，即使系统中没有其他可执行的线程，处于sleep()中的线程也不会执行，因此sleep()方法常用来暂停程序的执行。

释放CPU，进入阻塞状态

阻塞指定的时间

时间没有到，Cpu空闲，也不会提前结束阻塞状态

sleep()方法有两种重载形式

- **static void sleep(long millis)** :让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和调度程序精度和准确性的影响。
- **static void sleep(long millis, int nanos)  :**让当前正在执行的线程暂停millis毫秒+nanos毫微秒，并进入阻塞状态，该方法受到系统计时器和调度程序精度和准确性的影响。

代码演示

~~~java
public class Test{
    public static void main(String[] args) throws InterruptedException {
        for(int i=0;i<10;i++){
            System.out.println("当前时间:"+new Date());
            Thread.sleep(1000);//调用sleep()方法让当前线程(主线程 main线程)暂停1s
        }
    }
}
~~~

![运行截图](https://img-blog.csdnimg.cn/20210129151359214.png)

## 2.3 yield ()

屈服  投降  礼让

- 让当前正在执行线程暂停，不是阻塞线程，而是将线程转入就绪状态
- yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次，完全可能:当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。
- 实际上，当某个线程调用了yield()方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。

- 如果调用了yield方法之后，没有其他等待执行的线程，这个时候当前线程就会马上恢复执行！

让出CPU，进入就绪状态

目的：让相同或者更高优先级别的线程得到执行的机会

完全有可能刚刚yield CPU, 马上又获得了CPU

**关于sleep()方法和yield()方法的区别如下**

- sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级：但yield()方法只会给优先级相同，或优先级更高的线程执行机会。
- sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。因此完全有可能某个线程被 yield()方法暂停之后，立即再次获得处理器资源被执行。
- sleep()方法声明抛出了InterruptedException异常，所以调用sleep）方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。
- sleep()方法比yield()方法有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

## 2.4 setDaemon()

**后台线程**:如果所有的前台线程都死亡，后台线程将自动死亡。

可以将指定的线程设置成后台线程

创建后台线程的线程结束时，后台线程也随之消亡

调用Thread对象的setDaemon(true)方法可将指定线程设置为后台线程。

前台线程死亡后,JVM后通知后台线程死亡，但从它接受指令到做出响应，需要一定时间。

而且要将某个线程设置为后台线程，必须在该线程启动之前设置，也就是说setDaemon(true)必须在start()方法之前调用，否则会引发IllegalThreadStateException异常。

A线程中启动了B线程

A结束了，B也会随之结束

~~~java
public class Test extends Thread{
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println(getName()+" "+i);
        }
    }
    public static void main(String[] args) {
        Test t=new Test();
        t.setDaemon(true);//将线程t设置层后台线程
        t.start();
        for(int i=0;i<10;i++){
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
        //------程序执行到此处，前台线程(main线程)结束--------
        //后台线程也应该随之结束
    }
}
~~~

![运行截图](https://img-blog.csdnimg.cn/20210129151429182.png)

## 2.5 interrupt()

并没有直接中断线程，而是需要被中断线程自己处理

## 2.6 stop()

结束线程，不推荐使用

## 2.7 改变线程优先级

| 方法名                                  | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| final int getPriority()                 | 返回此线程的优先级                                           |
| final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |

- 每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。
- 每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。

# 3.线程同步

## 3.1 同步和异步区别

- 同步:客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作

- 异步:客户端不需要等待服务器端的响应。在服务器处理请求的过程种，客户端可以进行其他操作

Java中交互方式分为同步和异步两种：

- 同步交互：发送一个请求，需要等待返回，然后才能够发送下一个请求，有个等待过程
- 异步交互：发送一个请求，不需要等待返回，随时可以再发送下一个请求，即不需要等待

两者区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

哪些情况建议使用同步交互呢？比如银行的转账系统，对数据库的保存操作等等，都会使用同步交互操作，其余情况都优先使用异步交互

## 3.2 卖票和取款【应用】

### 3.2.1 卖票

- 案例需求

  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票

- 实现步骤

  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;

  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下

  - 判断票数大于0，就卖票，并告知是哪个窗口卖的
  - 卖了票之后，总票数要减1
  - 票卖没了，线程停止
  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下
  - 创建SellTicket类的对象
  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
  - 启动线程

- 代码实现

  ```java
  public class SellTicket implements Runnable {
      private int tickets = 100;
      //在SellTicket类中重写run()方法实现卖票，代码步骤如下
      @Override
      public void run() {
          while (true) {
              if(ticket <= 0){
                      //卖完了
                      break;
                  }else{
                      try {
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      ticket--;
                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                  }
          }
      }
  }
  public class SellTicketDemo {
      public static void main(String[] args) {
          //创建SellTicket类的对象
          SellTicket st = new SellTicket();

          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
          Thread t1 = new Thread(st,"窗口1");
          Thread t2 = new Thread(st,"窗口2");
          Thread t3 = new Thread(st,"窗口3");

          //启动线程
          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```

结果

~~~
窗口一在卖票，还剩下26张票
窗口二在卖票，还剩下25张票
窗口三在卖票，还剩下25张票
窗口一在卖票，还剩下24张票
窗口二在卖票，还剩下22张票
窗口三在卖票，还剩下22张票
窗口一在卖票，还剩下21张票
窗口三在卖票，还剩下20张票
窗口二在卖票，还剩下19张票
窗口一在卖票，还剩下18张票
窗口二在卖票，还剩下17张票
窗口三在卖票，还剩下16张票
窗口一在卖票，还剩下15张票
窗口二在卖票，还剩下13张票
窗口三在卖票，还剩下13张票
窗口一在卖票，还剩下12张票
窗口二在卖票，还剩下10张票
窗口三在卖票，还剩下10张票
窗口一在卖票，还剩下9张票
窗口三在卖票，还剩下8张票
窗口二在卖票，还剩下7张票
窗口一在卖票，还剩下6张票
窗口三在卖票，还剩下5张票
窗口二在卖票，还剩下4张票
窗口一在卖票，还剩下3张票
窗口二在卖票，还剩下2张票
窗口三在卖票，还剩下1张票
窗口一在卖票，还剩下0张票
窗口三在卖票，还剩下-2张票
窗口二在卖票，还剩下-2张票
~~~

### 3.2.2 取款

应用场景：

多个用户同时操作一个银行账户,初始余额为600。每次取款400元，取款前先检查余额是否足够。如果不够，放弃取款

分析

使用多线程解决

开发一个取款线程类，每个用户对应一个线程对象

因为多个线程共享同一个银行账户，使用Runnable方式解决

思路

创建银行账户类Account

创建取款线程AccountRunnable

创建测试类TestAccount，让两个用户同时取款

~~~java
public class Account {
    private int balance = 600;

    public int getBalance() {
        return balance;
    }

    public void withdraw(int money) {
        this.balance = this.balance - money;
    }
}

public class AccountRunnable implements Runnable {
    private Account account = new Account();

    @Override
    public void run() {
        if (account.getBalance() >= 400) {
            try {
                Thread.sleep(1);//模拟线程切换，一个线程让出CPU，另外一个线程获取CPU
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //取款
            account.withdraw(400);
            //输出取款信息
            System.out.println(Thread.currentThread().getName() +
                    "取款成功，现在余额：" + account.getBalance());
        } else {
            //输出无法取款信息
            System.out.println(Thread.currentThread().getName() +
                    "无法取款，余额不足：" + account.getBalance());
        }
    }
}

public class TestAccount {
    public static void main(String[] args) {
        //创建两个线程对象
        Runnable target = new AccountRunnable();

        Thread th1 = new Thread(target);
        //Thread th2 = new Thread(target);
        Thread th2 = new Thread(target ,"张三妻子");
        th1.setName("张三");
        //th2.setName("张三妻子");

        //启动线程
        th1.start();
        th2.start();
    }
}

~~~

![运行截图](https://img-blog.csdnimg.cn/20210129151500948.png)

由以上运行截图可知，当我们使用多个线程访问同一资源时，且多个线程中对资源有写的操作，就容易出现线程安全问题。

当多个线程访问同一个数据时，容易出现线程安全问题。需要让线程同步，保证数据安全

## 3.3 卖票案例的问题

- 卖票出现了问题

  - 相同的票出现了多次

  - 出现了负数的票

- 问题产生原因

  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题

当我们使用多个线程访问同一资源时，且多个线程中对资源有写的操作，就容易出现线程安全问题。

当多个线程访问同一个数据时，容易出现线程安全问题。需要让线程同步，保证数据安全

**线程同步**：当两个或两个以上线程访问同一资源时，需要某种方式来确保资源在**某一时刻只被一个线程使用**

**线程同步的实现方案**

1. 同步代码块 

   synchronized (obj){    }

2. 同步方法 

   private synchronized void makeWithdrawal(int amt) {}

3. Lock锁

**线程同步 优点和缺点**

- 优点：安全
- 缺点：效率低下  可能出现死锁

**死锁**

当两个线程相互等待对方释放“锁”时就会发生死锁

出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

多线程编程时应该注意避免死锁的发生

## 3.4  方案一:同步代码块解决数据安全问题

- 安全问题出现的条件

  - 是多线程环境

  - 有共享数据

  - 有多条语句操作共享数据

- 如何解决多线程安全问题呢?

  - 基本思想：让程序没有安全问题的环境

- 怎么实现呢?

  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

  - Java提供了同步代码块的方式来解决

- 同步代码块格式：

  ```java
  // obj称为同步监视器
  synchronized(任意对象obj) { 
  	多条语句操作共享数据的代码，可能会出现线程安全问题的代码(访问了共享数据的代码)
  }
  ```

  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁

  同步代码块中同步监视器可以是任何对象，但是推荐使用共享资源作为同步监视器

  同步方法中无需指定同步监视器，因为同步方法的同步监视器是this，也就是该对象本身

- 同步监视器相关注意事项:

  1. 必须是引用数据类型，不能是基本数据类型
  2. 在同步代码块中可以改变同步监视器对象的值，不能改变其引用
  3. 尽量不要String和包装类Integer做同步监视器.如果使用了，只要保证代码块中不对其进行任何操作也没有关系
  4. 一般使用共享资源做同步监视器即可
  5. 也可以创建一个专门的同步监视器，没有任何业务含义
  6. 建议使用final修饰同步监视器

- 同步的好处和弊端  

  - 好处：解决了多线程的数据安全问题
- 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率
  
- 同步代码块的执行过程

  1. 第一个线程来到同步代码块，发现同步监视器open状态，需要close,然后执行其中的代码
  2. 第一个线程执行过程中，发生了线程切换（阻塞 就绪），第一个线程失去了cpu，但是没有开锁open
  3. 第二个线程获取了cpu，来到了同步代码块，发现同步监视器close状态，无法执行其中的代码，第二个线程也进入阻塞状态
  4. 第一个线程再次获取CPU,接着执行后续的代码；同步代码块执行完毕，释放锁open
  5. 第二个线程也再次获取cpu，来到了同步代码块，发现同步监视器open状态，重复第一个线程的处理过程（加锁）

  强调：同步代码块中能发生线程切换吗？能！ 但是后续的被执行的线程也无法执行同步代码块（锁仍旧close）

  

- 其他
  1. 多个代码块使用了同一个同步监视器（锁），锁住一个代码块的同时，也锁住所有使用该锁的所有代码块，其他线程无法访问其中的任何一个代码块
  2. 多个代码块使用了同一个同步监视器（锁），锁住一个代码块的同时，也锁住所有使用该锁的所有代码块，但是没有锁住使用其他同步监视器的代码块，其他线程有机会访问其他同步监视器的代码块

- 代码演示

  ```java
  public class SellTicket implements Runnable {
      private int tickets = 100;
      private Object obj = new Object();
  
      @Override
      public void run() {
          while (true) {
              synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁
                  //t1进来后，就会把这段代码给锁起来
                  if (tickets > 0) {
                      try {
                          Thread.sleep(100);
                          //t1休息100毫秒
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      //窗口1正在出售第100张票
                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");
                      tickets--; //tickets = 99;
                  }
              }
              //t1出来了，这段代码的锁就被释放了
          }
      }
  }
  
  public class SellTicketDemo {
      public static void main(String[] args) {
          SellTicket st = new SellTicket();
  
          Thread t1 = new Thread(st, "窗口1");
          Thread t2 = new Thread(st, "窗口2");
          Thread t3 = new Thread(st, "窗口3");
  
          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```

取款案例

~~~java
public class AccountRunnable implements  Runnable{
    private final Account account= new Account();
    Object obj = new Object();
    byte [] bytes = new byte[1];
    @Override
    public void run() {
        //此处省略300句
          synchronized(account){
            if(account.getBalance()>=400){
                try {
                    Thread.sleep(1);//模拟线程切换，一个线程让出CPU，另外一个线程获取CPU
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //取款
                account.withdraw(400);
                //输出取款信息
                System.out.println(Thread.currentThread().getName()+
                        "取款成功，现在余额："+account.getBalance());
            }else{
                //输出无法取款信息
                System.out.println(Thread.currentThread().getName()+
                        "无法取款，余额不足："+account.getBalance());
            }
        }
        //此处省略200句
    }
    public void method1(){
        synchronized (account){
        }
    }
    public void method2(){
        synchronized (obj){
        }
    }
    public void method3(){
        synchronized (obj){
        }
    }
}
~~~



## 3.5 方案二:同步方法解决数据安全问题

- 同步方法的格式

  同步方法：就是把synchronized关键字加到方法上

  ```java
  修饰符 synchronized 返回值类型 方法名(方法参数) { 
  	方法体；
  }
  ```

  同步方法的锁对象是什么呢?  this

- 同步静态方法：就是把synchronized关键字加到静态方法上

  ```java
修饰符 static synchronized 返回值类型 方法名(方法参数) { 
  	方法体；
  }
  ```
  
  同步静态方法的锁对象是什么呢?        类名.class

  不能是this，this是创建对象之后产生的,静态方法优先于对象

   静态方法的锁对象是本类的class属性-->class文件对象(反射)

- 同步代码块和同步方法的区别:

  - 同步代码块可以锁住指定代码，同步方法是锁住方法中所有代码
  - 同步代码块可以指定锁对象，同步方法不能指定锁对象
  
- 注意

  1. 不要给run加锁

  2. 同步代码块和同步方法 效率高低

     同步方法效率低

     1. 同步方法是锁在了方法之外，同步代码块是已经进入了方法，锁在了同步代码块之外

     2. 一个线程锁住了一个同步方法，就锁住了所有的同步方法

  3. 线程安全的类：StringBuffer，Vector，Hashtable

  4. synchronized关键字可以修饰方法，可以修饰代码块，但不能修饰构造器，成员变量等

  5. 对于非static方法，同步锁就是this

     对应static方法，我们使用当前方法所在类的字节码对象(类名.class)

- 释放同步监视器的锁定

  任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢?程序无法显式释放对同步监视器的锁定，

  **线程会在如下几种情况下释放对同步监视器的锁定。**

  - 当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器。
  - 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行，当前线程将会释放同步监视器。
  - 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致了该代码块、该方法异常结束时，当前线程将会释放同步监视器。
  - 当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的**wait()**方法，则当前线程暂停，并释放同步监视器。

  **在如下所示的情况下，线程不会释放同步监视器。**

  - 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield)方法来暂停当前线程的执行，当前线程不会释放同步监视器。

  - 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器。当然，程序应该尽量避免使用suspend()和resume()方法来控制线程。

- 代码演示

  ```java
  public class MyRunnable implements Runnable {
      private static int ticketCount = 100;

      @Override
      public void run() {
          while(true){
              if("窗口一".equals(Thread.currentThread().getName())){
                  //同步方法
                  boolean result = synchronizedMthod();
                  if(result){
                      break;
                  }
              }

              if("窗口二".equals(Thread.currentThread().getName())){
                  //同步代码块
                  synchronized (MyRunnable.class){
                      if(ticketCount == 0){
                         break;
                      }else{
                          try {
                              Thread.sleep(10);
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                          ticketCount--;
                          System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");
                      }
                  }
              }

          }
      }

      private static synchronized boolean synchronizedMthod() {
          if(ticketCount == 0){
              return true;
          }else{
              try {
                  Thread.sleep(10);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              ticketCount--;
              System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticketCount + "张票");
              return false;
          }
      }
  }
  
  public class Demo {
        public static void main(String[] args) {
            MyRunnable mr = new MyRunnable();
            Thread t1 = new Thread(mr);
        	  Thread t2 = new Thread(mr);
            t1.setName("窗口一");
            t2.setName("窗口二");
            t1.start();
            t2.start();
    	  }
  }
  ```

## 3.6 方案三:Lock锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

与采用synchronized相比，lock可提供多种锁方案，更灵活

java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。

ReentrantLock,ReentrantReadWriteLock.ReadLock,ReentrantReadWriteLock.WriteLock

ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。

 **注意**：如果同步代码有异常，要将unlock()写入finally语句块

Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化

- ReentrantLock构造方法

  | 方法名          | 说明                        |
  | --------------- | --------------------------- |
  | ReentrantLock() | 创建一个ReentrantLock的实例 |

- 加锁解锁方法

  | 方法名        | 说明   |
  | ------------- | ------ |
  | void lock()   | 获得锁 |
  | void unlock() | 释放锁 |

- **使用步骤**

  1. 在成员位置创建一个ReentrantLock对象
  2. 在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
  3. 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁

- **Lock和synchronized的区别**

  1. Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁
  2. Lock只有代码块锁，synchronized有代码块锁和方法锁
  3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）

- **三种同步方案优先使用顺序**：Lock----同步代码块（已经进入了方法体，分配了相应资源）----同步方法（在方法体之外）

- 代码演示

  ```java
public class Ticket implements Runnable {
      //票的数量
      private int ticket = 100;
      private Object obj = new Object();
      private ReentrantLock lock = new ReentrantLock();

      @Override
      public void run() {
          while (true) {
              //synchronized (obj){//多个线程必须使用同一把锁.
              try {
                  lock.lock();
                  if (ticket <= 0) {
                      //卖完了
                      break;
                  } else {
                      Thread.sleep(100);
                      ticket--;
                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                  }
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } finally {
                  lock.unlock();
              }
              // }
          }
      }
  }

  public class Demo {
      public static void main(String[] args) {
          Ticket ticket = new Ticket();

          Thread t1 = new Thread(ticket);
          Thread t2 = new Thread(ticket);
          Thread t3 = new Thread(ticket);

          t1.setName("窗口一");
          t2.setName("窗口二");
          t3.setName("窗口三");

          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```

## 3.7 使用线程锁打印10次abc

~~~java
package com.cw.面试题;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author 陈小哥cw
 * @date 2021/1/21 16:45
 */
public class PrintABC {
    private static Lock lock = new ReentrantLock();//通过JDK5中的锁来保证线程的访问的互斥
    private static int state = 0;

    static class ThreadA extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; ) {
                lock.lock();
                if (state % 3 == 0) {
                    System.out.print("A");
                    state++;
                    i++;
                }
                lock.unlock();
            }
        }
    }

    static class ThreadB extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; ) {
                lock.lock();
                if (state % 3 == 1) {
                    System.out.print("B");
                    state++;
                    i++;
                }
                lock.unlock();
            }
        }
    }

    static class ThreadC extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; ) {
                lock.lock();
                if (state % 3 == 2) {
                    System.out.print("C");
                    state++;
                    i++;
                }
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}

~~~

## 3.8 死锁【理解】

+ 概述

  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

  当两个线程相互等待对方释放“锁”时就会发生死锁

  出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

  多线程编程时应该注意避免死锁的发生

+ 什么情况下会产生死锁

  1. 资源有限
  2. 同步嵌套

+ 代码演示

  ```java
  public class Demo {
      public static void main(String[] args) {
          Object objA = new Object();
          Object objB = new Object();

          new Thread(()->{
              while(true){
                  synchronized (objA){
                      //线程一
                      synchronized (objB){
                          System.out.println("小康同学正在走路");
                      }
                  }
              }
          }).start();

          new Thread(()->{
              while(true){
                  synchronized (objB){
                      //线程二
                      synchronized (objA){
                          System.out.println("小薇同学正在走路");
                      }
                  }
              }
          }).start();
      }
  }
  ```

# 4.生产者消费者(线程通信)

## 4.1生产者和消费者模式概述【应用】

- 概述

  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。

  所谓生产者消费者问题，实际上主要是包含了两类线程：

  ​	一类是生产者线程用于生产数据

  ​	一类是消费者线程用于消费数据

  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库

  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为

  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为

- Object类的等待和唤醒方法

  | 方法名           | 说明                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |
  | void notify()    | 唤醒正在等待对象监视器的单个线程                             |
  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                             |

## 4.2 生产者和消费者案例

### 4.2.1 厨师吃货案例

案例需求

+ 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量

+ 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务

  1.判断是否有包子,决定当前线程是否执行

  2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子

  3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子

+ 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务

  1.判断是否有包子,决定当前线程是否执行

  2.如果没有包子,就进入等待状态,如果有包子,就消费包子

  3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子

+ 测试类(Demo)：里面有main方法，main方法中的代码步骤如下

  创建生产者线程和消费者线程对象

  分别开启两个线程

- 代码实现

  ```java
  public class Desk {
  
      //定义一个标记
      //true 就表示桌子上有汉堡包的,此时允许吃货执行
      //false 就表示桌子上没有汉堡包的,此时允许厨师执行
      public static boolean flag = false;
  
      //汉堡包的总数量
      public static int count = 10;
  
      //锁对象
      public static final Object lock = new Object();
  }
  
  public class Cooker extends Thread {
  //    生产者步骤：
  //            1，判断桌子上是否有汉堡包
  //    如果有就等待，如果没有才生产。
  //            2，把汉堡包放在桌子上。
  //            3，叫醒等待的消费者开吃。
      @Override
      public void run() {
          while(true){
              synchronized (Desk.lock){
                  if(Desk.count == 0){
                      break;
                  }else{
                      if(!Desk.flag){
                          //生产
                          System.out.println("厨师正在生产汉堡包");
                          Desk.flag = true;
                          Desk.lock.notifyAll();
                      }else{
                          try {
                              Desk.lock.wait();
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                      }
                  }
              }
          }
      }
  }
  
  public class Foodie extends Thread {
      @Override
      public void run() {
  //        1，判断桌子上是否有汉堡包。
  //        2，如果没有就等待。
  //        3，如果有就开吃
  //        4，吃完之后，桌子上的汉堡包就没有了
  //                叫醒等待的生产者继续生产
  //        汉堡包的总数量减一
  
          //套路:
              //1. while(true)死循环
              //2. synchronized 锁,锁对象要唯一
              //3. 判断,共享数据是否结束. 结束
              //4. 判断,共享数据是否结束. 没有结束
          while(true){
              synchronized (Desk.lock){
                  if(Desk.count == 0){
                      break;
                  }else{
                      if(Desk.flag){
                          //有
                          System.out.println("吃货在吃汉堡包");
                          Desk.flag = false;
                          Desk.lock.notifyAll();
                          Desk.count--;
                      }else{
                          //没有就等待
                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.
                          try {
                              Desk.lock.wait();
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                      }
                  }
              }
          }
  
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          /*消费者步骤：
          1，判断桌子上是否有汉堡包。
          2，如果没有就等待。
          3，如果有就开吃
          4，吃完之后，桌子上的汉堡包就没有了
                  叫醒等待的生产者继续生产
          汉堡包的总数量减一*/
  
          /*生产者步骤：
          1，判断桌子上是否有汉堡包
          如果有就等待，如果没有才生产。
          2，把汉堡包放在桌子上。
          3，叫醒等待的消费者开吃。*/
  
          Foodie f = new Foodie();
          Cooker c = new Cooker();
  
          f.start();
          c.start();
  
      }
  }
  ```

### 4.2.2 厨师吃货案例案例优化

+ 需求

  + 将Desk类中的变量,采用面向对象的方式封装起来
  + 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用
  + 创建生产者和消费者线程对象,构造方法中传入Desk类对象
  + 开启两个线程

+ 代码实现

  ```java
  public class Desk {
  
      //定义一个标记
      //true 就表示桌子上有汉堡包的,此时允许吃货执行
      //false 就表示桌子上没有汉堡包的,此时允许厨师执行
      //public static boolean flag = false;
      private boolean flag;
  
      //汉堡包的总数量
      //public static int count = 10;
      //以后我们在使用这种必须有默认值的变量
     // private int count = 10;
      private int count;
  
      //锁对象
      //public static final Object lock = new Object();
      private final Object lock = new Object();
  
      public Desk() {
          this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了
      }
  
      public Desk(boolean flag, int count) {
          this.flag = flag;
          this.count = count;
      }
  
      public boolean isFlag() {
          return flag;
      }
  
      public void setFlag(boolean flag) {
          this.flag = flag;
      }
  
      public int getCount() {
          return count;
      }
  
      public void setCount(int count) {
          this.count = count;
      }
  
      public Object getLock() {
          return lock;
      }
  
      @Override
      public String toString() {
          return "Desk{" +
                  "flag=" + flag +
                  ", count=" + count +
                  ", lock=" + lock +
                  '}';
      }
  }
  
  public class Cooker extends Thread {
  
      private Desk desk;
  
      public Cooker(Desk desk) {
          this.desk = desk;
      }
  //    生产者步骤：
  //            1，判断桌子上是否有汉堡包
  //    如果有就等待，如果没有才生产。
  //            2，把汉堡包放在桌子上。
  //            3，叫醒等待的消费者开吃。
  
      @Override
      public void run() {
          while(true){
              synchronized (desk.getLock()){
                  if(desk.getCount() == 0){
                      break;
                  }else{
                      //System.out.println("验证一下是否执行了");
                      if(!desk.isFlag()){
                          //生产
                          System.out.println("厨师正在生产汉堡包");
                          desk.setFlag(true);
                          desk.getLock().notifyAll();
                      }else{
                          try {
                              desk.getLock().wait();
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                      }
                  }
              }
          }
      }
  }
  
  public class Foodie extends Thread {
      private Desk desk;
  
      public Foodie(Desk desk) {
          this.desk = desk;
      }
  
      @Override
      public void run() {
  //        1，判断桌子上是否有汉堡包。
  //        2，如果没有就等待。
  //        3，如果有就开吃
  //        4，吃完之后，桌子上的汉堡包就没有了
  //                叫醒等待的生产者继续生产
  //        汉堡包的总数量减一
  
          //套路:
              //1. while(true)死循环
              //2. synchronized 锁,锁对象要唯一
              //3. 判断,共享数据是否结束. 结束
              //4. 判断,共享数据是否结束. 没有结束
          while(true){
              synchronized (desk.getLock()){
                  if(desk.getCount() == 0){
                      break;
                  }else{
                      //System.out.println("验证一下是否执行了");
                      if(desk.isFlag()){
                          //有
                          System.out.println("吃货在吃汉堡包");
                          desk.setFlag(false);
                          desk.getLock().notifyAll();
                          desk.setCount(desk.getCount() - 1);
                      }else{
                          //没有就等待
                          //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.
                          try {
                              desk.getLock().wait();
                          } catch (InterruptedException e) {
                              e.printStackTrace();
                          }
                      }
                  }
              }
          }
  
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          /*消费者步骤：
          1，判断桌子上是否有汉堡包。
          2，如果没有就等待。
          3，如果有就开吃
          4，吃完之后，桌子上的汉堡包就没有了
                  叫醒等待的生产者继续生产
          汉堡包的总数量减一*/
  
          /*生产者步骤：
          1，判断桌子上是否有汉堡包
          如果有就等待，如果没有才生产。
          2，把汉堡包放在桌子上。
          3，叫醒等待的消费者开吃。*/
  
          Desk desk = new Desk();
  
          Foodie f = new Foodie(desk);
          Cooker c = new Cooker(desk);
  
          f.start();
          c.start();
  
      }
  }
  ```

## 4.3 线程通信引入

**应用场景1：生产者和消费者问题**

假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费

如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止

如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止

![img](https://img-blog.csdnimg.cn/20210129151600286.png)

**应用场景2:**

假设现在系统中有两个线程，这两个线程分别代表存款者和取钱者—现在假设系统有一种特殊的要求，系统要求存款者和取钱者不断地重复存款、取钱的动作，而且要求每当存款者将钱存入指定账户后，取钱者就立即取出该笔钱。不允许存款者连续两次存钱，也不允许取钱者连续两次取钱。

**分析**

这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件

对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费

对于消费者，在消费之后，要通知生产者已经消费结束，需要继续生产新产品以供消费

1. 生产和消费交替进行
2. 生产者交替的生产白色馒头和黄色的玉米饼
3. 生产者------仓库-------消费者（仓库中只能存放一件商品）

在生产者消费者问题中，仅有synchronized是不够的

synchronized可阻止并发更新同一个共享资源，实现了同步

synchronized不能用来实现不同线程之间的消息传递（通信）

**类的设计**

1. 定义一个商品Product类
2. 定义两个线程：生产者线程，消费者线程
3. 定义测试类：创建线程并启动 

**注意**

1. 生产者线程和消费者线程是两个不同的线程
2. 之前的取款线程、选手线程只要执行代码，不同线程之间没有交流
3. 现在的生产者线程、消费者线程需要相互通信（还有商品吗？没有，告诉生产者，生产吧）
4. 同样也需要线程同步，保证安全性（线程通信的前提是线程同步） 

**缺点**

- 缺点1：没有实现交替的生产和消费

  解决1：线程通信  wait()  notify()  notifyAll() 

- 缺点2：和商品没有关系

  解决2：添加一个商品类

- 缺点3：生产者生产的商品没有被消费者消费，消费者总是消费null

  原因：生产者和消费者没有共用一个商品

  解决

  ~~~java
  Product product = new Product();
  Runnable target1 = new ProductRunnable(product);
  Runnable target2 = new ConsumeRunnable(product);
  ~~~

- 缺点4：为什么消费者出现了黄色的馒头和白色的玉米饼

  原因：缺少线程同步

  注意：生产者和消费者都要加锁，并且必须是同一把锁

  生产者关锁后，即使sleep() 释放了CPU，即使消费者得到了CPU，结果发现代码上锁，无法消费

**解决**

为了实现这种功能，可以借助于Object类提供的wait()、notify()和notifyAll()三个方法，这三个方法并不属于Thread类，而是属于Object类。但这三个方法必须由同步监视器对象来调用，这可分成以下两种情况。

- 对于使用synchronized修饰的**同步方法**，因为该类的**默认实例（this)**就是同步监视器，所以可以在同步方法中直接调用这三个方法。
- 对于使用synchronized修饰的**同步代码块**，同步监视器是synchronized后**括号里的对象**，所以必须使用该对象调用这三个方法。

关于这三个方法的解释如下。

- wait():导致当前线程等待，直到其他线程调用该同步监视器的notify(）方法或notifyAll()方法来唤醒该线程。该wait()方法有三种形式—无时间参数的wait(一直等待，直到其他线程通知）、带毫秒参数的wait（)和带毫秒、毫微秒参数的wait()(这两种方法都是等待指定时间后自动苏醒)。**调用wait（)方法的当前线程会释放对该同步监视器的锁定。**
- notify():唤醒在此同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会选择唤醒其中一个线程。选择是任意性的。只有当前线程放弃对该同步监视器的锁定后(使用wait()方法)，才可以执行被唤醒的线程。

- notifyAll():唤醒在此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。

## 4.4 线程通信的细节

**细节1**：进行线程通信的多个线程，要使用同一个同步监视器（product），还必须要调用该同步监视器的wait()、notify()、notifyAll();     

**细节2**：线程通信的三个方法

- **wait() 等待** 

  在【其他线程】调用【此对象】的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。

  换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。

  当前线程必须拥有此对象监视器。

- **wait(time) 等待**

  在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。

  当前线程必须拥有此对象监视器。

- **notify() 通知  唤醒**

  唤醒在【此对象监视器】上等待的【单个】线程。

  如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。【选择是任意性的】，并在对实现做出决定时发生

- **notifyAll() 通知所有  唤醒所有**

  唤醒在【此对象监视器】上等待的【所有】线程

  被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程【进行竞争】；

以上方法均是`java.lang.Object`类的方法,都只能在同步方法或者同步代码块中使用，否则会抛出异常

**细节3**：完整的线程生命周期

阻塞状态有三种

- 普通的阻塞  sleep,join,Scanner input.next()
- 同步阻塞（锁池队列） 没有获取同步监视器的线程的队列
- 等待阻塞（阻塞队列） 被调用了wait()后释放锁，然后进行该队列 

![完整的线程生命周期](https://img-blog.csdnimg.cn/20210129151626622.png)

**细节4**：sleep()和yield()的区别；sleep()和wait()的区别

- 区别1:

  sleep()线程会让出CPU进入阻塞状态，但不会释放对象锁

  wait() 线程会让出CPU进入阻塞状态， 【也会放弃对象锁】，进入等待【此对象】的等待锁定池

  进入的阻塞状态也是不同的队列

- 区别2：

  wait只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用

## 4.5 使用同步代码块实现线程通信

程序中可以通过一个旗标来标识仓库中是否已有商品，当旗标为false时，表明仓库中没有商品，生产者线程可以向下执行，当生产者生产一个商品后，将旗标设为true，并调用notify()或notifyAll()方法来唤醒其他线程；当生产者线程进入线程体后，如果旗标为true就调用wait()方法(调用wait()会释放同步代码块的锁)让该线程等待(代表仓库中已有商品，不能再生产了)。

当旗标为true时，表明仓库中已经存在商品，则消费者线程可以向下执行，当消费者消费商品后，将旗标设为false(代表仓库中已无商品了)，并调用notify(）或notifyAll()方法来唤醒其他线程；当取钱者线程进入线程体后，如果旗标为false就调用wait（)方法让该线程等待。

生产者线程

~~~java
public class ProduceRunnable implements Runnable{
   // private Product product = new Product();
    private Product product;
    public ProduceRunnable() {
    }
    public ProduceRunnable(Product product) {
        this.product = product;
    }
    public Product getProduct() {
        return product;
    }
    public void setProduct(Product product) {
        this.product = product;
    }
    @Override
    public void run() {
        int i=0;
        while(true){
            synchronized (product){
                //1.如果有商品，就等待
                if(product.flag){
                    try {
                        product.wait();// 等待 必须调用同步监视器的wait()   进入阻塞状态（当前同步监视器的的等待队列） 释放CPU，同时释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //2.生产并输出商品
                if(  i%2==0){
                    product.setName("馒头");
                    try {
                        Thread.sleep(1);//线程切换  进入了阻塞状态，让出了CPU，就是不释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    product.setColor("白色");
                }else{
                    product.setName("玉米饼");
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    product.setColor("黄色");
                }
                System.out.println("生产者生产了商品："+product.getName()+"  "+product.getColor());
                //3.有商品了
                product.flag = true;
                //4.通知消费者
                product.notify();//通知  唤醒  必须是同步监视器的notify()
            }
            i++;
        }
    }
}
~~~

消费者线程

~~~java
public class ConsumeRunnable implements  Runnable {
    private Product product;
    public Product getProduct() {
        return product;
    }
    public void setProduct(Product product) {
        this.product = product;
    }
    @Override
    public void run() {
        while(true){
            synchronized (product){//product不见名称相同，关键是执行一个对象
                //1.如果没有商品，就等待
                if(!product.flag){
                    try {
                        product.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //2.消费商品
                System.out.println("消费者在消费商品："+product.getName()+"  "+product.getColor());
                //3.没有商品了
                product.flag = false;
                //4.通知生产者
                product.notifyAll();
            }
        }
    }
}
~~~

商品类

~~~java
public class Product {
    private String name;//馒头、玉米饼
    private String color;//白色、黄色
    boolean flag = false;//默认没有商品
    public Product() {
    }
    public Product(String name, String color) {
        this.name = name;
        this.color = color;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }
    @Override
    public String toString() {
        return "Product{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                '}';
    }
}
~~~

测试类

~~~java
 public class Test {
	public static void main(String[] args) {
		Product product = new Product();
		//创建一个生产者线程和消费者线程
		Runnable target1 = new ProductRunnable(product);
		Thread thread1 = new Thread(target1);
		Runnable target2 = new ConsumeRunnable(product);
		Thread thread2 = new Thread(target2);
		//生产者和消费者线程实现交替的生产和消费
		thread1.start();
		thread2.start();
	}
}
~~~

## 4.6 使用同步方法实现线程通信

生产者线程

~~~java
public class ProduceRunnable implements Runnable{
   // private Product product = new Product();
    private Product product;
    public ProduceRunnable() {
    }
    public ProduceRunnable(Product product) {
        this.product = product;
    }
    public Product getProduct() {
        return product;
    }
    public void setProduct(Product product) {
        this.product = product;
    }
    @Override
    public void run() {
        int i=0;
        while(true){
            if(i%2==0){
                product.produce("馒头","白色");
            }else{
                product.produce("玉米饼","黄色");
            }
            i++;
        }
    }
}
~~~

消费者线程

~~~java
public class ConsumeRunnable implements  Runnable {
    private Product product;
    public Product getProduct() {
        return product;
    }
    public void setProduct(Product product) {
        this.product = product;
    }
    @Override
    public void run() {
        while(true){
           product.consume();
        }
    }
}
~~~

商品类

~~~java
/**
 * 商品类
 */
public class Product {
    private String name;//馒头、玉米饼
    private String color;//白色、黄色
    boolean flag = false;//默认没有商品
    public Product() {
    }
    public Product(String name, String color) {
        this.name = name;
        this.color = color;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }
    @Override
    public String toString() {
        return "Product{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                '}';
    }
    /**
     * 生产商品
     */
    public synchronized void produce(String name,String color){//this
        //1.如果有商品，就等待
        if(flag){
            try {
                this.wait();// 等待 必须调用同步监视器的wait()   进入阻塞状态（当前同步监视器的的等待队列） 释放CPU，同时释放锁
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //2.生产并输出商品
        this.name = name;
        try {
            Thread.sleep(1);//线程切换  进入了阻塞状态，让出了CPU，就是不释放锁
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.color = color;
        System.out.println("生产者生产了商品："+getName()+"  "+getColor());
        //3.有商品了
        flag = true;
        //4.通知消费者
        this.notify();//通知  唤醒  必须是同步监视器的notify()
    }
    /**
     * 消费商品
     */
    public synchronized void consume(){//this
        //1.如果没有商品，就等待
        if(!flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //2.消费商品
        System.out.println("消费者在消费商品："+name+"  "+color);
        //3.没有商品了
        flag = false;
        //4.通知生产者
        this.notifyAll();
    }
}
~~~





## 4.7 阻塞队列基本使用【理解】

+ 阻塞队列继承结构

  ![06_阻塞队列继承结构](https://img-blog.csdnimg.cn/20210129151651641.png)


+ 常见BlockingQueue:

  ArrayBlockingQueue: 底层是数组,有界

  LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值

+ BlockingQueue的核心方法:

  put(anObject): 将参数放入队列,如果放不进去会阻塞

  take(): 取出第一个数据,取不到会阻塞

+ 代码示例

  ```java
  public class Demo02 {
      public static void main(String[] args) throws Exception {
          // 创建阻塞队列的对象,容量为 1
          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);
  
          // 存储元素
          arrayBlockingQueue.put("汉堡包");
  
          // 取元素
          System.out.println(arrayBlockingQueue.take());
          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞
  
          System.out.println("程序结束了");
      }
  }
  ```

## 4.8 阻塞队列实现等待唤醒机制【理解】

+ 案例需求

  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务

    1.构造方法中接收一个阻塞队列对象

    2.在run方法中循环向阻塞队列中添加包子

    3.打印添加结果

  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务

    1.构造方法中接收一个阻塞队列对象

    2.在run方法中循环获取阻塞队列中的包子

    3.打印获取结果

  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下

    创建阻塞队列对象

    创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象

    分别开启两个线程

+ 代码实现

  ```java
  public class Cooker extends Thread {
  
      private ArrayBlockingQueue<String> bd;
  
      public Cooker(ArrayBlockingQueue<String> bd) {
          this.bd = bd;
      }
  //    生产者步骤：
  //            1，判断桌子上是否有汉堡包
  //    如果有就等待，如果没有才生产。
  //            2，把汉堡包放在桌子上。
  //            3，叫醒等待的消费者开吃。
  
      @Override
      public void run() {
          while (true) {
              try {
                  bd.put("汉堡包");
                  System.out.println("厨师放入一个汉堡包");
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  public class Foodie extends Thread {
      private ArrayBlockingQueue<String> bd;
  
      public Foodie(ArrayBlockingQueue<String> bd) {
          this.bd = bd;
      }
  
      @Override
      public void run() {
  //        1，判断桌子上是否有汉堡包。
  //        2，如果没有就等待。
  //        3，如果有就开吃
  //        4，吃完之后，桌子上的汉堡包就没有了
  //                叫醒等待的生产者继续生产
  //        汉堡包的总数量减一
  
          //套路:
          //1. while(true)死循环
          //2. synchronized 锁,锁对象要唯一
          //3. 判断,共享数据是否结束. 结束
          //4. 判断,共享数据是否结束. 没有结束
          while (true) {
              try {
                  String take = bd.take();
                  System.out.println("吃货将" + take + "拿出来吃了");
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
  
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);
  
          Foodie f = new Foodie(bd);
          Cooker c = new Cooker(bd);
  
          f.start();
          c.start();
      }
  }
  ```

  

# 5.线程池

## 5.1 线程状态介绍

### 5.1.1 概述

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程

状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：

```java
public class Thread {
    
    public enum State {
    
        /* 新建 */
        NEW , 

        /* 可运行状态 */
        RUNNABLE , 

        /* 阻塞状态 */
        BLOCKED , 

        /* 无限等待状态 */
        WAITING , 

        /* 计时等待 */
        TIMED_WAITING , 

        /* 终止 */
        TERMINATED;
    
	}
    
    // 获取当前线程的状态
    public State getState() {
        return jdk.internal.misc.VM.toThreadState(threadStatus);
    }
    
}
```

通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下

| 线程状态      | 具体含义                                                     |
| ------------- | ------------------------------------------------------------ |
| NEW           | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 |
| RUNNABLE      | 当我们**调用线程对象的start方法**，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 |
| BLOCKED       | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 |
| WAITING       | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 |
| TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 |
| TERMINATED    | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态     |

各个状态的转换，如下图所示：

![1591163781941](https://img-blog.csdnimg.cn/20210129151722889.png)

![线程状态转换图](https://img-blog.csdnimg.cn/20210129151751944.png)

### 5.1.2 新生状态(New)

一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。  

用new关键字建立一个线程对象后，该线程对象就处于新生状态。

处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态，但该线程并未真正进入运行状态。

**注意**:只能对处于新建状态的线程调用start()方法，否则将引发IllegalThreadStateException异常

### 5.1.2 就绪状态(Runnable)

当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。  

处于就绪状态线程具备了运行条件，但还没分配到CPU，处于线程就绪队列，等待系统为其分配CPU

当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该动作称之为“cpu调度”。

就绪状态相当于"等待执行"

### 5.1.3 运行状态(Running)

在运行状态的线程执行自己的run方法中代码，直到等待某资源而阻塞或完成任务而死亡。

如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态。

如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程**并行**执行;当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。

### 5.1.4 阻塞状态(Blocked)

当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。  

处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 

在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如**睡眠时间已到**，或**等待的I/O设备空闲下来**，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来   停止的位置开始继续运行。

当发生如下情况时，线程将会进入阻塞状态。

- 线程调用slecp()方法主动放弃所占用的处理器资源。
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
- 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。
- 线程在等待某个通知(notify)。
- 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。

### 5.1.5 无限等待(WAITING)

一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。

### 5.1.6 计时等待(TIMED_WAITING)

一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。  

### 5.1.5 死亡状态(TERMINATED)

一个完全运行完成的线程的状态。也称之为终止状态、结束状态

死亡状态是线程生命周期中的最后一个阶段。

线程死亡的原因有三个。

+ 一个是正常运行的线程完成了它的全部工作(run()或call()方法执行完成，线程正常结束)；

- 二是线程被强制性地终止，如通过执行stop方法来终止一个线程【容易导致死锁,不推荐使用】，

- 三是线程抛出未捕获的异常

## 5.2 线程的状态-练习1

**目的 :** 本案例主要演示TIME_WAITING的状态转换。

**需求：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE -> TERMINATED

为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。

**代码实现**

```java
public class ThreadStateDemo01 {

    public static void main(String[] args) throws InterruptedException {

        //定义一个内部线程
        Thread thread = new Thread(() -> {
            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());
            try {
                //休眠100毫秒
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("4.执行Thread.sleep(long)完成之后，线程的状态：" + Thread.currentThread().getState());
        });

        //获取start()之前的状态
        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread.getState());

        //启动线程
        thread.start();

        //休眠50毫秒
        Thread.sleep(50);

        //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态
        System.out.println("3.执行Thread.sleep(long)时，线程的状态：" + thread.getState());

        //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕
        Thread.sleep(100);

        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState() + "\n");

    }

}
```

控制台输出

```java
1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW
2.执行thread.start()之后，线程的状态：RUNNABLE
3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING
4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE
5.线程执行完毕之后，线程的状态：TERMINATED
```

## 5.3 线程的状态-练习2

**目的 :** 本案例主要演示WAITING的状态转换。

**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> WAITING -> RUNNABLE -> TERMINATED

**代码实现 :** 

```java
public class ThreadStateDemo02 {

    public static void main(String[] args) throws InterruptedException {

        //定义一个对象，用来加锁和解锁
        Object obj = new Object();

        //定义一个内部线程
        Thread thread1 = new Thread(() -> {
            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());
            synchronized (obj) {
                try {

                    //thread1需要休眠100毫秒
                    Thread.sleep(100);

                    //thread1100毫秒之后，通过wait()方法释放obj对象是锁
                    obj.wait();
                    
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("4.被object.notify()方法唤醒之后，线程的状态：" + Thread.currentThread().getState());
        });

        //获取start()之前的状态
        System.out.println("1.通过new初始化一个线程，但是还没有start()之前，线程的状态：" + thread1.getState());

        //启动线程
        thread1.start();

        //main线程休眠150毫秒
        Thread.sleep(150);

        //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态
        System.out.println("3.执行object.wait()时，线程的状态：" + thread1.getState());

        //声明另一个线程进行解锁
        new Thread(() -> {
            synchronized (obj) {
                //唤醒等待的线程
                obj.notify();
            }
        }).start();

        //main线程休眠10毫秒等待thread1线程能够苏醒
        Thread.sleep(10);

        //获取thread1运行结束之后的状态
        System.out.println("5.线程执行完毕之后，线程的状态：" + thread1.getState() + "\n");

    }

}
```

控制台输出结果

```java
1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW
2.执行thread.start()之后，线程的状态：RUNNABLE
3.执行object.wait()时，线程的状态：WAITING
4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE
5.线程执行完毕之后，线程的状态：TERMINATED
```

## 5.4 线程的状态-练习3

**目的 :**   本案例主要演示BLOCKED的状态转换。

**需求 ：**编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> BLOCKED -> RUNNABLE -> TERMINATED

```java
public class ThreadStateDemo03 {

    public static void main(String[] args) throws InterruptedException {

        //定义一个对象，用来加锁和解锁
        Object obj2 = new Object();

        //定义一个线程，先抢占了obj2对象的锁
        new Thread(() -> {
            synchronized (obj2) {
                try {
                    Thread.sleep(100);              //第一个线程要持有锁100毫秒
                    obj2.wait();                          //然后通过wait()方法进行等待状态，并释放obj2的对象锁
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        //定义目标线程，获取等待获取obj2的锁
        Thread thread = new Thread(() -> {
            System.out.println("2.执行thread.start()之后，线程的状态：" + Thread.currentThread().getState());
            synchronized (obj2) {
                try {
                    Thread.sleep(100);              //thread3要持有对象锁100毫秒
                    obj2.notify();                        //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("4.阻塞结束后，线程的状态：" + Thread.currentThread().getState());
        });

        //获取start()之前的状态
        System.out.println("1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：" + thread.getState());

        //启动线程
        thread.start();

        //先等100毫秒
        Thread.sleep(50);

        //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞
        System.out.println("3.因为等待锁而阻塞时，线程的状态：" + thread.getState());

        //再等300毫秒
        Thread.sleep(300);

        //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕
        System.out.println("5.线程执行完毕之后，线程的状态：" + thread.getState());

    }

}
```

**控制台输出结果**

```java
1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW
2.执行thread.start()之后，线程的状态：RUNNABLE
3.因为等待锁而阻塞时，线程的状态：BLOCKED
4.阻塞结束后，线程的状态：RUNNABLE
5.线程执行完毕之后，线程的状态：TERMINATED
```

## 5.5 线程池-基本原理

### 5.5.1 线程池引入

创建和销毁对象是非常耗费时间的

创建对象：需要分配内存等资源

销毁对象：虽然不需要程序员操心，但是垃圾回收器会在后台一直跟踪并销毁

对于经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。

思路：创建好多个线程，放入线程池中，使用时直接获取引用，不使用时放回池中。可以避免频繁创建销毁、实现重复利用

系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短智的线程时，更应该考虑使用线程池。

与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行它们的run()或call（)方法，当run()或call（)方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run（)或call()方法。

技术案例：线程池、数据库连接池

JDK1.5起，提供了内置线程池

### 5.5.2 线程池介绍

**概述 :** 

提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。

**线程池存在的意义：**

系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理时对系统资源的消耗，这样就有点"舍本逐末"了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。

**线程池的设计思路 :**

1. 准备一个任务容器
2. 一次性启动多个(2个)消费者线程
3. 刚开始任务容器是空的，所以线程都在wait
4. 直到一个外部线程向这个任务容器中扔了一个"任务"，就会有一个消费者线程被唤醒
5. 这个消费者线程取出"任务"，并且执行这个任务，执行完毕后，继续等待下一次任务的到来

**线程池的好处**

提高响应速度（减少了创建新线程的时间）		

降低资源消耗（重复利用线程池中线程，不需要每次都创建）

提高线程的可管理性：避免线程无限制创建、从而销耗系统资源，降低系统稳定性，甚至内存溢出或者CPU耗尽

**线程池的应用场合**

需要大量线程，并且完成任务的时间端

对性能要求苛刻

接受突发性的大量请求

### 5.5.2 线程池详细介绍

在Java5以前，开发者必须手动实现自己的线程池：从Java5开始，Java内建支持线程池。Java5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。

- **newCachedThreadPool()**:创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中。
- **newFixedThreadPool(int nThreads)**:创建一个可重用的、具有圈定线程数的线程池。
- **newSingle ThreadExecutor（)**:创建一个只有单线程的线程池，它相当于调用newFixedThread Pool)方法时传入参数为1.
- **newScheduledThreadPool(int corePoolSizc)**:创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池内。
- **newSingleThreadScheduledExecutor()**:创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。
- **ExecutorService new WorkStealingPool(int parallelism)**:创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争。
- **ExecutorService newWorkStealingPool()**:该方法是前一个方法的简化版本。如果当前机器有4个CPU，则目标并行级别被设置为4，也就是相当于为前一个方法传入4作为参数。

上面7个方法中的前三个方法返回一个ExecutorService对象，该对象代表一个线程池，它可以执行Runnable 对象或Callable对象所代表的线程；而中间两个方法返回一个ScheduledExecutorService线程池，它是ExecutorService的子类，它可以在指定延迟后执行线程任务；最后两个方法则是Java8新增的，这两个方法可充分利用多CPU并行的能力。这两个方法生成的work stealing池，都相当于后台线程池，如果所有的前台线程都死亡了，work stealing池中的线程会自动死亡。

由于目前计算机硬件的发展日新月异，即使普通用户使用的电脑通常也都是多核CPU，因此Java8在线程支持上也增加了利用多CPU并行的能力，这样可以更好地发挥底层硬件的性能。

**ExecutorService**代表尽快执行线程的线程池（只要线程池中有空闲线程，就立即执行线程任务)，程序只要将一个Runnable对象或Callable对象(代表线程任务)提交给该线程池，该线程池就会尽快执行该任务。ExecutorService里提供了如下三个方法。

- `Future<?> submit(Runnable task)`:将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable任务的返回值----------但run()方法没有返回值，所以Future对象将在run（)方法执行结束后返回null。但可以调用Future的isDone()、isCancelled()方法来获得Runnable对象的执行状态。
- `<T>Future<T>submit(Runnable task,T result)`:将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中result显式指定线程执行结束后的返回值，所以Future对象将在run()方法执行结束后返回result。
- `<T>Future<T> submit(Callable<T>task)`:将一个Callable对象提交给指定的线程池，线程池将在有空闲线程时执行Callable对象代表的任务。其中Future代表Callable对象里call()方法的返回值。

**ScheduledExecutorService**代表可在指定延迟后或周期性地执行线程任务的线程池，它提供了如下4个方法。

- `ScheduledFuture<V>schedule(Callable<V> callable,long delay,TimeUnit unit)`:指定callable任务将在delay延迟后执行。
- `ScheduledFuture<?> schedule(Runnable command,long delay,TimeUnit unit)`:指定command任务将在delay延迟后执行。
- `ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDeiay,long period,TimeUnit unit)`:指定command任务将在delay延迟后执行，而且以设定频率重复执行。也就是说，在initialDelay后开始执行，依次在initialDelay+period、initialDelay+2*period…处重复执行，依此类推。

- `ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)`:创建并执行一个在给定初始延迟后首次启用的定期操作，随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务在任一次执行时遇到异常，就会取消后续执行；否则，只能通过程序来显式取消或终止该任务。

### 5.5.3 线程池API

- `Executor`：线程池顶级接口，只有一个方法 void execute(Runnable command);
- `ExecutorService`：真正的线程池接口
  - `void execute(Runnable command)`：执行任务/命令，没有返回值，一般用来执行Runnable
  - `<T> Future<T> submit(Callable<T> task)`：执行任务，有返回值，一般用来执行Callable
  - `void shutdown() `：关闭连接池
- `AbstractExecutorService`：基本实现了ExecutorService的所有方法	
- `ThreadPoolExecutor`：默认的线程池实现类
- `ScheduledThreadPoolExecutor`：实现周期性任务调度的线程池
- `Executors`：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 
  - `Executors.newCachedThreadPool()`：创建一个可根据需要创建新线程的线程池	
  - `Executors.newFixedThreadPool(n)`;  创建一个可重用固定线程数的线程池
  - `Executors.newSingleThreadExecutor()` ：创建一个只有一个线程的线程池
  - `Executors.newScheduledThreadPool(n)`：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。	

## 5.6 线程池-Executors默认线程池

概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。

我们可以使用Executors中所提供的**静态**方法来创建线程池

- static ExecutorService newCachedThreadPool()   创建一个默认的线程池
- static ExecutorService newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池

**java.util.concurrent.ExecutorService:线程池接口**

用来从线程池中获取线程,调用start方法,执行线程任务

- submit(Runnable task) 提交一个 Runnable 任务用于执行

- void shutdown() 关闭/销毁线程池的方法

**线程池的使用步骤:**

1. 使用线程池的工厂类Executors里边提供的静态工厂方法生产一个指定线程数量的线程池（ExecutorService对象）
2. 创建一个类,实现Runnable接口,重写run方法,设置线程任务
3. 调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法
4. 调用ExecutorService中的方法shutdown销毁线程池(不建议执行)

**代码实现:** 

```java
package com.itheima.mythreadpool;


//static ExecutorService newCachedThreadPool()   创建一个默认的线程池
//static newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MyThreadPoolDemo {
    public static void main(String[] args) throws InterruptedException {

        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Executors --- 可以帮助我们创建线程池对象
        //ExecutorService --- 可以帮助我们控制线程池

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        //Thread.sleep(2000);

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        executorService.shutdown();
    }
}

```

## 5.7 线程池-Executors创建指定上限的线程池

**使用Executors中所提供的静态方法来创建线程池**

​	static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池

**代码实现 :** 

```java
package com.itheima.mythreadpool;

//static ExecutorService newFixedThreadPool(int nThreads)
//创建一个指定最多线程数量的线程池

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class MyThreadPoolDemo2 {
    public static void main(String[] args) {
        //参数不是初始值而是最大值
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;
        System.out.println(pool.getPoolSize());//0

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName() + "在执行了");
        });

        System.out.println(pool.getPoolSize());//2
//        executorService.shutdown();
    }
}

```

## 5.8 线程池-ThreadPoolExecutor

**创建线程池对象 :** 

ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);

~~~java
public ThreadPoolExecutor(int corePoolSize,
          int maximumPoolSize,
          long keepAliveTime,
          TimeUnit unit,
          BlockingQueue<Runnable> workQueue,
          ThreadFactory threadFactory,
          RejectedExecutionHandler handler) {
}
~~~

![img](https://img-blog.csdnimg.cn/20210129151833548.png)

**线程池参数**

- corePoolSize：核心池的大小
  - 默认情况下，创建了线程池后，线程数为0，当有任务来之后，就会创建一个线程去执行任务。
  - 但是当线程池中线程数量达到corePoolSize，就会把到达的任务放到队列中等待。

  - maximumPoolSize：最大线程数。
  - corePoolSize和maximumPoolSize之间的线程数会自动释放，小于等于corePoolSize的不会释放。当大于了这个值就会将任务由一个丢弃处理机制来处理。
  - keepAliveTime：线程没有任务时最多保持多长时间后会终止 	
      - 默认只限于corePoolSize和maximumPoolSize之间的线程
  - TimeUnit：
      - keepAliveTime的时间单位
  - BlockingQueue：
      - 存储等待执行的任务的阻塞队列，有多中选择，可以是顺序队列、链式队列等。
  - ThreadFactory
      - 线程工厂，默认是DefaultThreadFactory，Executors的静态内部类
  - **RejectedExecutionHandler：**
      - 拒绝处理任务时的策略。如果线程池的线程已经饱和，并且任务队列也已满，对新的任务应该采取什么策略。
    - 比如抛出异常、直接舍弃、丢弃队列中最旧任务等，默认是直接抛出异常。
      1. DiscardPolicy：什么也不做
      2. AbortPolicy：java默认，抛出一个异常
      3. DiscardOldestPolicy：在线程池的等待队列中，将头取出一个抛弃，然后将当前线程放进去。
      4. CallerRunsPolicy：如果发现线程池还在运行，就直接运行这个线程


**代码实现 :** 

```java
package com.itheima.mythreadpool;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class MyThreadPoolDemo3 {
//    参数一：核心线程数量
    //    参数二：最大线程数
    //    参数三：空闲线程最大存活时间
    //    参数四：时间单位  -- TimeUnit
    //    参数五：任务队列  -- 让任务在队列中等着，等有线程空闲了，再从这个队列中获取任务并执行
    //    参数六：创建线程工厂 -- 按照默认的方式创建线程对象
    //    参数七：任务的拒绝策略 -- 1.什么时候拒绝任务  提交的任务数 > 池中最大线程数量 + 队列容量
    //                             2.如何拒绝
    public static void main(String[] args) {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(
            2,
            5,
            2,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10), 
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy()
        );
        pool.submit(new MyRunnable());
        pool.submit(new MyRunnable());

        pool.shutdown();
    }
}
```

## 5.9 线程池-参数详解

![1591165506516](https://img-blog.csdnimg.cn/20210129151856748.png)

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
    
corePoolSize：   核心线程的最大值，不能小于0
maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize
keepAliveTime：  空闲线程最大存活时间,不能小于0
unit：           时间单位
workQueue：      任务队列，不能为null
threadFactory：  创建线程工厂,不能为null      
handler：        任务的拒绝策略,不能为null  
```

## 5.10 线程池-非默认任务拒绝策略

RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。

```java
ThreadPoolExecutor.AbortPolicy: 		    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。
ThreadPoolExecutor.DiscardPolicy： 		   丢弃任务，但是不抛出异常 这是不推荐的做法。
ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。
ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。
```

注：明确线程池对最多可执行的任务数 = 队列容量 + 最大线程数

>  什么时候拒绝任务?   当 提交的任务数 > 池中最大线程数量 + 队列容量 时

**案例演示1**：演示ThreadPoolExecutor.AbortPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo01 {

    public static void main(String[] args) {

        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;

        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常
        for(int x = 0 ; x < 5 ; x++) {
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务");
            });
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-1---->> 执行了任务
pool-1-thread-3---->> 执行了任务
pool-1-thread-2---->> 执行了任务
pool-1-thread-3---->> 执行了任务
```

控制台报错，仅仅执行了4个任务，有一个任务被丢弃了



**案例演示2**：演示ThreadPoolExecutor.DiscardPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo02 {
    public static void main(String[] args) {
        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;

        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错
        for(int x = 0 ; x < 5 ; x++) {
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务");
            });
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-1---->> 执行了任务
pool-1-thread-1---->> 执行了任务
pool-1-thread-3---->> 执行了任务
pool-1-thread-2---->> 执行了任务
```

控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了



**案例演示3**：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo02 {
    public static void main(String[] args) {
        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor;
        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());
        // 提交5个任务
        for(int x = 0 ; x < 5 ; x++) {
            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰
            final int y = x ;
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务" + y);
            });     
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-2---->> 执行了任务2
pool-1-thread-1---->> 执行了任务0
pool-1-thread-3---->> 执行了任务3
pool-1-thread-1---->> 执行了任务4
```

由于任务1在线程池中等待时间最长，因此任务1被丢弃。



**案例演示4**：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略

```java
public class ThreadPoolExecutorDemo04 {
    public static void main(String[] args) {

        /**
         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s
         */
        ThreadPoolExecutor threadPoolExecutor;
        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,
                new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());

        // 提交5个任务
        for(int x = 0 ; x < 5 ; x++) {
            threadPoolExecutor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "---->> 执行了任务");
            });
        }
    }
}
```

**控制台输出结果**

```java
pool-1-thread-1---->> 执行了任务
pool-1-thread-3---->> 执行了任务
pool-1-thread-2---->> 执行了任务
pool-1-thread-1---->> 执行了任务
main---->> 执行了任务
```

通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。

## 5.11 线程池的使用

### 5.11.1 使用线程池执行大量的Runnable命令（没有返回值）

~~~java
public class TestThreadPool {
    public static void main(String[] args) {
        //创建一个线程池
        //线程池中只有一个线程，保证肯定会有一个
        //ExecutorService pool = Executors.newSingleThreadExecutor();
        //线程池中有固定数量的线程
        ExecutorService pool = Executors.newFixedThreadPool(10);
        //线程池中线程的数量是不固定的，可以动态变化（增加、减少）
        //ExecutorService pool = Executors.newCachedThreadPool();
        //线程池用来执行一些定时或者周期性的任务
        //ExecutorService pool4 = Executors.newScheduledThreadPool(10);
        
        //使用线程池（执行大量的Runnable命令）
        for(int i=0;i<20;i++){
            //final int n = i;
            int n = i;
            //定义任务
            Runnable command = new Runnable(){
                @Override
                public void run() {
                    System.out.println("任务开始"+n);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("任务结束"+n);
                }
            };
            //
            //new Thread(command);
            pool.execute(command);
        }
        //关闭线程池
        pool.shutdown();
    }
}

//class MyRunnable implements  Runnable{
//    @Override
//    public void run() {
//        System.out.println("任务开始");
//        try {
//            Thread.sleep(2000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        System.out.println("任务结束");
//    }
//}
~~~

### 5.11.2 使用线程池执行大量的Callable任务（有返回值）

~~~java
public class TestThreadPool2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建一个线程池
        ExecutorService pool = Executors.newFixedThreadPool(10);

        //使用线程池（执行大量的Callable任务）
        List<Future> list = new ArrayList<Future>();
        for (int i=0;i< 20;i++){
            //指定任务
            Callable<Integer> task = new Callable(){
                @Override
                public Object call() throws Exception {
                    Thread.sleep(2000);
                    return new Random().nextInt(10);
                }
            };
            //交个线程池
            Future<Integer> future = pool.submit(task);
            //得到结果并输出
            //int result = future.get();//阻塞的方法
            //System.out.println(result);
            list.add(future);
        }

        for(Future<Integer> f :list){
            Integer result = f.get();
            System.out.println(result);

        }
        //关闭线程池
        pool.shutdown();
    }
}

//class MyCallable implements Callable<Integer>{
//
//    @Override
//    public Integer call() throws Exception {
//        Thread.sleep(2000);
//        return new Random().nextInt(10);
//    }
//}

~~~



# 6. 原子性

## 6.1 volatile-问题

**代码分析 :** 

```java
package com.itheima.myvolatile;

public class Demo {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        t1.setName("小路同学");
        t1.start();

        MyThread2 t2 = new MyThread2();
        t2.setName("小皮同学");
        t2.start();
    }
}
```

```java
package com.itheima.myvolatile;

public class Money {
    public static int money = 100000;
}
```

```java
package com.itheima.myvolatile;

public class MyThread1 extends  Thread {
    @Override
    public void run() {
        while(Money.money == 100000){

        }

        System.out.println("结婚基金已经不是十万了");
    }
}

```

```java
package com.itheima.myvolatile;

public class MyThread2 extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Money.money = 90000;
    }
}

```

**程序问题 :**  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。



## 6.2 volatile解决

**以上案例出现的问题 :**

当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 

1. 堆内存是唯一的，每一个线程都有自己的线程栈。
2. 每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。
3. 在线程中，每一次使用是从变量的副本中获取的。

**Volatile关键字 :** 强制线程每次在使用的时候，都会看一下共享区域最新的值

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

**volatile 的特性**

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）
- 禁止进行指令重排序。（实现有序性）
- volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性。关于volatile 原子性可以理解为把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步，就跟下面的SoWhat跟SynSoWhat功能类似哦。

**volatile和synchronized两者之间比较：**

1. 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好；
2. volatile只能修饰变量，而synchronized可以修饰方法、代码块等。
3. 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。
4. volatile能保证数据的可见性，但不能保证数据的原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步处理。
5. 关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。

**代码实现 :** **使用volatile关键字解决**

```java
package com.itheima.myvolatile;

public class Demo {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        t1.setName("小路同学");
        t1.start();

        MyThread2 t2 = new MyThread2();
        t2.setName("小皮同学");
        t2.start();
    }
}
```

```java
package com.itheima.myvolatile;

public class Money {
    public static volatile int money = 100000;
}
```

```java
package com.itheima.myvolatile;

public class MyThread1 extends  Thread {
    @Override
    public void run() {
        while(Money.money == 100000){

        }

        System.out.println("结婚基金已经不是十万了");
    }
}

```

```java
package com.itheima.myvolatile;

public class MyThread2 extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Money.money = 90000;
    }
}

```



## 6.3 synchronized解决

**synchronized解决 :** 

1. 线程获得锁
2. 清空变量副本
3. 拷贝共享变量最新的值到变量副本中
4. 执行代码
5. 将修改后变量副本中的值赋值给共享数据
6. 释放锁

**代码实现 :** 

```java
package com.itheima.myvolatile2;

public class Demo {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        t1.setName("小路同学");
        t1.start();

        MyThread2 t2 = new MyThread2();
        t2.setName("小皮同学");
        t2.start();
    }
}
```

```java
package com.itheima.myvolatile2;

public class Money {
    public static Object lock = new Object();
    public static volatile int money = 100000;
}
```

```java
package com.itheima.myvolatile2;

public class MyThread1 extends  Thread {
    @Override
    public void run() {
        while(true){
            synchronized (Money.lock){
                if(Money.money != 100000){
                    System.out.println("结婚基金已经不是十万了");
                    break;
                }
            }
        }
    }
}
```

```java
package com.itheima.myvolatile2;

public class MyThread2 extends Thread {
    @Override
    public void run() {
        synchronized (Money.lock) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            Money.money = 90000;
        }
    }
}
```



## 6.4 原子性

**概述 :** 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。

**代码实现 :** 

```java
package com.itheima.threadatom;

public class AtomDemo {
    public static void main(String[] args) {
        MyAtomThread atom = new MyAtomThread();

        for (int i = 0; i < 100; i++) {
            new Thread(atom).start();
        }
    }
}
class MyAtomThread implements Runnable {
    private volatile int count = 0; //送冰淇淋的数量

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            //1,从共享数据中读取数据到本线程栈中.
            //2,修改本线程栈中变量副本的值
            //3,会把本线程栈中变量副本的值赋值给共享数据.
            count++;
            System.out.println("已经送了" + count + "个冰淇淋");
        }
    }
}
```

**代码总结 :** count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断

volatile：只能保证线程每次在使用共享数据时是最新值，但是不能保证原子性



## 6.5 volatile关键字不能保证原子性

解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。 

```java
package com.itheima.threadatom2;

public class AtomDemo {
    public static void main(String[] args) {
        MyAtomThread atom = new MyAtomThread();

        for (int i = 0; i < 100; i++) {
            new Thread(atom).start();
        }
    }
}
class MyAtomThread implements Runnable {
    private volatile int count = 0; //送冰淇淋的数量
    private Object lock = new Object();

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            //1,从共享数据中读取数据到本线程栈中.
            //2,修改本线程栈中变量副本的值
            //3,会把本线程栈中变量副本的值赋值给共享数据.
            synchronized (lock) {
                count++;
                System.out.println("已经送了" + count + "个冰淇淋");
            }
        }
    }
}
```



## 6.6 原子性_AtomicInteger

概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。

因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。

本次我们只讲解使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：

AtomicBoolean： 原子更新布尔类型

AtomicInteger：   原子更新整型

AtomicLong：	原子更新长整型

以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：

```java
public AtomicInteger()：	   			    初始化一个默认值为0的原子型Integer
public AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integer

int get():   			 				获取值
int getAndIncrement():      			 以原子方式将当前值加1，注意，这里返回的是自增前的值。
int incrementAndGet():     				 以原子方式将当前值加1，注意，这里返回的是自增后的值。
int addAndGet(int data):				 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。
int getAndSet(int value):   			 以原子方式设置为newValue的值，并返回旧值。
```

**代码实现 :**

```java
package com.itheima.threadatom3;

import java.util.concurrent.atomic.AtomicInteger;

public class MyAtomIntergerDemo1 {
//    public AtomicInteger()：	               初始化一个默认值为0的原子型Integer
//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer
    public static void main(String[] args) {
        AtomicInteger ac = new AtomicInteger();
        System.out.println(ac);

        AtomicInteger ac2 = new AtomicInteger(10);
        System.out.println(ac2);
    }

}
```

```java
package com.itheima.threadatom3;

import java.lang.reflect.Field;
import java.util.concurrent.atomic.AtomicInteger;

public class MyAtomIntergerDemo2 {
//    int get():   		 		获取值
//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。
//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。
//    int addAndGet(int data):	 以原子方式将参数与对象中的值相加，并返回结果。
//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。
    public static void main(String[] args) {
//        AtomicInteger ac1 = new AtomicInteger(10);
//        System.out.println(ac1.get());

//        AtomicInteger ac2 = new AtomicInteger(10);
//        int andIncrement = ac2.getAndIncrement();
//        System.out.println(andIncrement);
//        System.out.println(ac2.get());

//        AtomicInteger ac3 = new AtomicInteger(10);
//        int i = ac3.incrementAndGet();
//        System.out.println(i);//自增后的值
//        System.out.println(ac3.get());

//        AtomicInteger ac4 = new AtomicInteger(10);
//        int i = ac4.addAndGet(20);
//        System.out.println(i);
//        System.out.println(ac4.get());

        AtomicInteger ac5 = new AtomicInteger(100);
        int andSet = ac5.getAndSet(20);
        System.out.println(andSet);
        System.out.println(ac5.get());
    }
}
```



## 6.7 AtomicInteger-内存解析(CAS算法)

**AtomicInteger原理 :** 自旋锁  + CAS 算法

**CAS算法：**

有3个操作数（内存值V， 旧的预期值A，要修改的值B）

当旧的预期值A == 内存值   此时修改成功，将V改为B                 

当旧的预期值A！=内存值   此时修改失败，不做任何操作                 

并重新获取现在的最新值（这个重新获取的动作就是自旋）

**总结**

CAS算法在修改共享数据时，把原来的旧值记录下来了。

如果现在内存中的值跟原来的旧值一样，证明没有其他线程操作过内存值，则修改成功

如果现在内存中的值跟原来的旧址不一样了，证明已经有其他线程操作过内存值了，则修改失败，需要获取现在最新的值，再次进行操作，这个重新获取就是自旋。

## 6.8 AtomicInteger-源码解析

**代码实现 :**

```java
package com.itheima.threadatom4;

public class AtomDemo {
    public static void main(String[] args) {
        MyAtomThread atom = new MyAtomThread();

        for (int i = 0; i < 100; i++) {
            new Thread(atom).start();
        }
    }
}
```

```java
package com.itheima.threadatom4;

import java.util.concurrent.atomic.AtomicInteger;

public class MyAtomThread implements Runnable {
    //private volatile int count = 0; //送冰淇淋的数量
    //private Object lock = new Object();
    AtomicInteger ac = new AtomicInteger(0);

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            //1,从共享数据中读取数据到本线程栈中.
            //2,修改本线程栈中变量副本的值
            //3,会把本线程栈中变量副本的值赋值给共享数据.
            //synchronized (lock) {
//                count++;
//                ac++;
            int count = ac.incrementAndGet();
            System.out.println("已经送了" + count + "个冰淇淋");
           // }
        }
    }
}

```

**源码解析 :** 

```java
private volatile int value;

public AtomicInteger(int initialValue) {
         value = initialValue;
}

/**
 * Creates a new AtomicInteger with initial value {@code 0}.
 */
public AtomicInteger() {
}

//先自增，然后获取自增后的结果
public final int incrementAndGet() {
        //+ 1 自增后的结果
        //this 就表示当前的atomicInteger（值）
        //1    自增一次
        return U.getAndAddInt(this, VALUE, 1) + 1;
}

public final int getAndAddInt(Object o, long offset, int delta) {
        //v 旧值
        int v;
        //自旋的过程
        do {
            //不断的获取旧值
            v = getIntVolatile(o, offset);
            //如果这个方法的返回值为false，那么继续自旋
            //如果这个方法的返回值为true，那么自旋结束
            //o 表示的就是内存值
            //v 旧值
            //v + delta 修改后的值
        } while (!weakCompareAndSetInt(o, offset, v, v + delta));
            //作用：比较内存中的值和旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。
            //                              如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。
            //如果修改失败，那么继续自旋。	
        return v;
}
```



## 6.9 悲观锁sysnchronized和乐观锁CAS

**synchronized和CAS的区别 :** 

**相同点：**在多线程情况下，都可以保证共享数据的安全性。

**不同点：**

- 悲观锁：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每次操作共享数据之前，都会上锁。

- 乐观锁：cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。
  - 如果别人修改过，那么我再次获取现在最新的值。
  - 如果别人没有修改过，那么我现在直接修改共享数据的值  

# 7. 并发工具类

## 7.1 并发工具类-Hashtable

**Hashtable出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。

注意：

1. Hashtable采取悲观锁synchronized的形式保证数据的安全性

2. 只要有线程访问，会将整张表全部锁起来，所以Hashtable的效率低下

**代码实现 :** 

```java
package com.itheima.mymap;

import java.util.HashMap;
import java.util.Hashtable;

public class MyHashtableDemo {
    public static void main(String[] args) throws InterruptedException {
        Hashtable<String, String> hm = new Hashtable<>();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 25; i++) {
                hm.put(i + "", i + "");
            }
        });


        Thread t2 = new Thread(() -> {
            for (int i = 25; i < 51; i++) {
                hm.put(i + "", i + "");
            }
        });

        t1.start();
        t2.start();

        System.out.println("----------------------------");
        //为了t1和t2能把数据全部添加完毕
        Thread.sleep(1000);

        //0-0 1-1 ..... 50- 50

        for (int i = 0; i < 51; i++) {
            System.out.println(hm.get(i + ""));
        }//0 1 2 3 .... 50


    }
}
```



## 7.2 并发工具类-ConcurrentHashMap基本使用

**ConcurrentHashMap出现的原因 :** 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。

基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。

**体系结构 :** 

![1591168965857](https://img-blog.csdnimg.cn/20210129151943244.png)

**总结 :** 

1. HashMap是线程不安全的。多线程环境下会有数据安全问题

2. Hashtable是线程安全的，但是会将整张表锁起来，效率低下

3. ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。

**代码实现 :** 

```java
package com.itheima.mymap;

import java.util.Hashtable;
import java.util.concurrent.ConcurrentHashMap;

public class MyConcurrentHashMapDemo {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap<>(100);

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 25; i++) {
                hm.put(i + "", i + "");
            }
        });


        Thread t2 = new Thread(() -> {
            for (int i = 25; i < 51; i++) {
                hm.put(i + "", i + "");
            }
        });

        t1.start();
        t2.start();

        System.out.println("----------------------------");
        //为了t1和t2能把数据全部添加完毕
        Thread.sleep(1000);

        //0-0 1-1 ..... 50- 50

        for (int i = 0; i < 51; i++) {
            System.out.println(hm.get(i + ""));
        }//0 1 2 3 .... 50
    }
}
```



## 7.3 并发工具类-ConcurrentHashMap1.7原理

![1591169254280](https://img-blog.csdnimg.cn/20210129152003743.png)

 ConcurrentHashMap 是由Segment 数组结构和HashEntry数组结构组成。

 Segment 是一种可重入锁（ReentrantLock），在ConcurrentHashMap 里扮演锁的角色。

 一个ConCurrentHashMap里包含一个 Segment数组。

 Segment的结构和HashMap 类似，是一种数组和链表结构。

 HashEntry 则用于存储键值 对数据。

模板：0索引处的数组

## 7.4 并发工具类-ConcurrentHashMap1.8原理

![1591169338256](https://img-blog.csdnimg.cn/20210129152025584.png)

底层结构：哈希表。(数组，链表，红黑树的结合体)

结合CAS机制+synchronized同步代码块形式保证线程安全

**总结 :** 

1. 如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表

2. 计算当前元素应存入的索引。

3. 如果该索引位置为null，则利用cas算法，将本结点添加到数组中。

4. 如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。		

5. 当链表的长度大于等于8时，自动转换成红黑树
6. 以链表或者红黑树头结点为锁对象，配合悲观锁(synchronized同步代码块)保证多线程操作集合时数据的安全性

## 7.5 ConcurrentHashMap 1.7和1.8版本区别

JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。

1. 数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。
2. 保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。
3. 锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。
4. 链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。
5. 查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。

## 7.5 并发工具类-CountDownLatch

**CountDownLatch类 :** 		

| 方法                             | 解释                             |
| -------------------------------- | -------------------------------- |
| public CountDownLatch(int count) | 参数传递线程数，表示等待线程数量 |
| public void await()              | 让线程等待                       |
| public void countDown()          | 当前线程执行完毕                 |

**使用场景：** 让某一条线程等待其他线程执行完毕之后再执行

**代码实现 :** 

```java
package com.itheima.mycountdownlatch;

import java.util.concurrent.CountDownLatch;

public class ChileThread1 extends Thread {

    private CountDownLatch countDownLatch;
    public ChileThread1(CountDownLatch countDownLatch) {
        this.countDownLatch = countDownLatch;
    }

    @Override
    public void run() {
        //1.吃饺子
        for (int i = 1; i <= 10; i++) {
            System.out.println(getName() + "在吃第" + i + "个饺子");
        }
        //2.吃完说一声
        //每一次countDown方法的时候，就让计数器-1
        countDownLatch.countDown();
    }
}

```

```java
package com.itheima.mycountdownlatch;

import java.util.concurrent.CountDownLatch;

public class ChileThread2 extends Thread {

    private CountDownLatch countDownLatch;
    public ChileThread2(CountDownLatch countDownLatch) {
        this.countDownLatch = countDownLatch;
    }
    @Override
    public void run() {
        //1.吃饺子
        for (int i = 1; i <= 15; i++) {
            System.out.println(getName() + "在吃第" + i + "个饺子");
        }
        //2.吃完说一声
        //每一次countDown方法的时候，就让计数器-1
        countDownLatch.countDown();
    }
}

```

```java
package com.itheima.mycountdownlatch;

import java.util.concurrent.CountDownLatch;

public class ChileThread3 extends Thread {

    private CountDownLatch countDownLatch;
    public ChileThread3(CountDownLatch countDownLatch) {
        this.countDownLatch = countDownLatch;
    }
    @Override
    public void run() {
        //1.吃饺子
        for (int i = 1; i <= 20; i++) {
            System.out.println(getName() + "在吃第" + i + "个饺子");
        }
        //2.吃完说一声
        //每一次countDown方法的时候，就让计数器-1
        countDownLatch.countDown();
    }
}

```

```java
package com.itheima.mycountdownlatch;

import java.util.concurrent.CountDownLatch;

public class MotherThread extends Thread {
    private CountDownLatch countDownLatch;
    public MotherThread(CountDownLatch countDownLatch) {
        this.countDownLatch = countDownLatch;
    }

    @Override
    public void run() {
        //1.等待
        try {
            //当计数器变成0的时候，会自动唤醒这里等待的线程。
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //2.收拾碗筷
        System.out.println("妈妈在收拾碗筷");
    }
}

```

```java
package com.itheima.mycountdownlatch;

import java.util.concurrent.CountDownLatch;

public class MyCountDownLatchDemo {
    public static void main(String[] args) {
        //1.创建CountDownLatch的对象，需要传递给四个线程。
        //在底层就定义了一个计数器，此时计数器的值就是3
        CountDownLatch countDownLatch = new CountDownLatch(3);
        //2.创建四个线程对象并开启他们。
        MotherThread motherThread = new MotherThread(countDownLatch);
        motherThread.start();

        ChileThread1 t1 = new ChileThread1(countDownLatch);
        t1.setName("小明");

        ChileThread2 t2 = new ChileThread2(countDownLatch);
        t2.setName("小红");

        ChileThread3 t3 = new ChileThread3(countDownLatch);
        t3.setName("小刚");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

**总结 :** 

​	1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。

​	2. await()：让线程等待，当计数器为0时，会唤醒等待的线程

​	3. countDown()： 线程执行完毕时调用，会将计数器-1。

## 7.6 并发工具类-Semaphore

**使用场景 :** 

​	可以控制访问特定资源的线程数量。

**实现步骤 :** 

​	1，需要有人管理这个通道    --> 创建Semaphore对象

​	2，当有车进来了，发通行许可证  --> acquire()发通行证

​	3，当车出去了，收回通行许可证  -->  release()收回通行证

​	4，如果通行许可证发完了，那么其他车辆只能等着 

**代码实现 :** 

```java
package com.itheima.mysemaphore;

import java.util.concurrent.Semaphore;

public class MyRunnable implements Runnable {
    //1.获得管理员对象
    // 最多运行两个线程同时执行
    private Semaphore semaphore = new Semaphore(2);
    @Override
    public void run() {
        //2.获得通行证
        try {
            semaphore.acquire();
            //3.开始行驶
            System.out.println("获得了通行证开始行驶");
            Thread.sleep(2000);
            System.out.println("归还通行证");
            //4.归还通行证
            semaphore.release();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

```java
package com.itheima.mysemaphore;

public class MySemaphoreDemo {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();

        for (int i = 0; i < 100; i++) {
            new Thread(mr).start();
        }
    }
}
```



# 8.ForkJoin框架

## 8.1 什么是ForkJoin框架 适用场景

虽然目前处理器核心数已经发展到很大数目，但是按任务并发处理并不能完全充分的利用处理器资源，因为一般的应用程序没有那么多的并发处理任务。基于这种现状，考虑把一个任务拆分成多个单元，每个单元分别得到执行，最后合并每个单元的结果。

Fork/Join框架是JAVA7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。

为了充分利用多CPU、多核CPU的性能优势，计算机软件系统应该可以充分“挖掘”每个CPU的计算能力，绝不能让某个CPU处于“空闲”状态。为了充分利用多CPU、多核CPU的优势，可以

考虑把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。

Java7提供了ForkJoinPool来支持将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。

ForkJoinPool提供了如下两个常用的构造器。

- **ForkJoinPool(int parallelism)**:创建一个包含parallelism个并行线程的ForkJoinPool。
- **ForkJoinPool()**:以Runtime.availableProcessors)方法的返回值作为parallelism 参数来创建ForkJoinPool。

Java8进一步扩展了ForkJoinPool的功能，Java8为ForkJoinPool增加了通用池功能。ForkJoinPool类通过如下两个静态方法提供通用池功能。

- **ForkJoinPool commonPool()**:该方法返回一个通用池，通用池的运行状态不会受shutdown)或shutdownNow)方法的影响。当然，如果程序直接执行System.exit(0)；来终止虚拟机，通用池以及通用池中正在执行的任务都会被自动终止。
- **int getCommonPoolParallelism()**:该方法返回通用池的并行级别。

创建了ForkJoinPool实例之后，就可调用ForkJoinPool 的submit(ForkJoinTask task)或 invoke(ForkJoinTask task)方法来执行指定任务了。其中ForkJoinTask代表一个可以并行、合并的任务。ForkJoinTask是一个抽象类，它还有两个抽象子类：RecursiveAction 和RecursiveTask。其中RecursiveTask代表有返回值的任务，而RecursiveAction代表没有返回值的任务。

![img](img/clipboard-1611302040139.png)

## 8.2 工作窃取算法（work-stealing）

一个大任务拆分成多个小任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列中，并且每个队列都有单独的线程来执行队列里的任务，线程和队列一一对应。

但是会出现这样一种情况：A线程处理完了自己队列的任务，B线程的队列里还有很多任务要处理。

A是一个很热情的线程，想过去帮忙，但是如果两个线程访问同一个队列，会产生竞争，所以A想了一个办法，从双端队列的尾部拿任务执行。而B线程永远是从双端队列的头部拿任务执行。

![img](https://img-blog.csdnimg.cn/20210129152054377.png)

注意：线程池中的每个线程都有自己的工作队列（PS，这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。

**工作窃取算法的优点：**

利用了线程进行并行计算，减少了线程间的竞争。

**工作窃取算法的缺点：**

1. 如果双端队列中只有一个任务时，线程间会存在竞争。

2. 窃取算法消耗了更多的系统资源，如会创建多个线程和多个双端队列。

## 8.3 主要类

1. ForkJoinTask

   使用该框架，需要创建一个ForkJoin任务，它提供在任务中执行fork和join操作的机制。一般情况下，我们并不需要直接继承ForkJoinTask类，只需要继承它的子类，它的子类有两个：

   - RecursiveAction:用于没有返回结果的任务。

   - RecursiveTask:用于有返回结果的任务。

2. ForkJoinPool

   任务ForkJoinTask需要通过ForkJoinPool来执行。

3. ForkJoinWorkerThread：

   ForkJoinPool线程池中的一个执行任务的线程。

## 8.4 使用示例

![img](https://img-blog.csdnimg.cn/2021012915211418.png)

~~~java
/**
 * 功能：计算 1+2+3......+n = ?
 *
 */
public class SumTask extends RecursiveTask<Long>{
    private int start;
    private int end;
    private final int step = 20000000;//最小拆分成几个数相加
    public SumTask(int start, int end) {
        this.start = start;
        this.end = end;
    }
    @Override
    protected Long compute() {
        long sum = 0;
        if(end - start <= step ){
            //小于5个数，直接求和
            for (int i = start; i <=end; i++) {
                sum+=i;
            }
        }else{
          //大于5个数，分解任务
            int mid = (end + start)/2;
            SumTask leftTask = new SumTask(start,mid);
            SumTask rightTask = new SumTask(mid+1,end);
            //执行子任务
            leftTask.fork();
            rightTask.fork();
            //子任务，执行完，得到执行结果
            long leftSum = leftTask.join();
            long rightSum = rightTask.join();
            sum = leftSum+rightSum;
        }
        return sum;
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //如果多核CPU，其实是一个一直使用，其他闲置；怎么办，多线程解决；
        //但是涉及到任务的拆分与合并等众多细节，不要紧，现在使用ForkJoin框架，可以较轻松解决；
        long  start = System.currentTimeMillis();
        long sum = 0;
        for(int i=0;i<=1000000000;i++){
            sum +=i;
        }
        System.out.println(sum);
        long end = System.currentTimeMillis();
        System.out.println("for:"+(end - start));
        //使用ForkJoin框架解决
        //创建一个线程池
        ForkJoinPool pool = new ForkJoinPool();
        //定义一个任务
        SumTask sumTask = new SumTask(1,1000000000);
        //将任务交给线程池
         start = System.currentTimeMillis();
        Future<Long> future = pool.submit(sumTask);
        //得到结果并输出
        Long result = future.get();
        System.out.println(result);
        end = System.currentTimeMillis();
        System.out.println("pool:"+(end - start));
    }
}
~~~

可以看出，使用了  ForkJoinPool 的实现逻辑全部集中在了  compute() 这个函数里，仅用了很少行就实现了完整的计算过程。特别是，在这段代码里没有显式地“把任务分配给线程”，只是分解了任务，而把具体的任务到线程的映射交给了  ForkJoinPool 来完成。